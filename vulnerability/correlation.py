# vulnerability/correlation.py

from typing import List, Dict
import logging
from .models import Vulnerability
from datetime import datetime

class VulnerabilityCorrelator:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def correlate_findings(self, internal_results: List[Dict], zap_results: List[Dict], 
                          openvas_results: List[Dict], target: str) -> List[Dict]:
        """Correlate findings from multiple scanners"""
        try:
            # Normalize findings from each scanner
            normalized_findings = []
            
            # Process internal scanner results
            for finding in internal_results:
                normalized = self._normalize_internal_finding(finding)
                normalized_findings.append(normalized)

            # Process ZAP results
            for finding in zap_results:
                normalized = self._normalize_zap_finding(finding)
                normalized_findings.append(normalized)

            # Process OpenVAS results
            for finding in openvas_results:
                normalized = self._normalize_openvas_finding(finding)
                normalized_findings.append(normalized)

            # Correlate and deduplicate findings
            correlated_findings = self._correlate_findings(normalized_findings)
            
            # Save correlated findings
            saved_findings = self._save_findings(correlated_findings, target)
            
            return saved_findings

        except Exception as e:
            self.logger.error(f"Error correlating findings: {str(e)}")
            return []

    def _normalize_internal_finding(self, finding: Dict) -> Dict:
        """Normalize internal scanner findings"""
        return {
            'name': finding.get('name'),
            'description': finding.get('description', ''),
            'severity': finding.get('severity', 'LOW'),
            'evidence': finding.get('evidence', ''),
            'source': 'internal',
            'confidence': finding.get('confidence', 'medium'),
            'type': finding.get('type', 'unknown'),
            'references': finding.get('references', []),
            'metadata': {
                'original_source': 'internal_scanner',
                'original_id': finding.get('id'),
                'scan_date': datetime.now().isoformat()
            }
        }

    def _normalize_zap_finding(self, finding: Dict) -> Dict:
        """Normalize ZAP findings"""
        return {
            'name': finding.get('name'),
            'description': finding.get('description', ''),
            'severity': self._map_zap_severity(finding.get('risk')),
            'evidence': finding.get('evidence', ''),
            'source': 'zap',
            'confidence': finding.get('confidence', 'medium'),
            'type': 'web',
            'references': finding.get('references', []),
            'metadata': {
                'original_source': 'zap',
                'original_id': finding.get('id'),
                'cweid': finding.get('cweid'),
                'wascid': finding.get('wascid'),
                'scan_date': datetime.now().isoformat()
            }
        }

    def _normalize_openvas_finding(self, finding: Dict) -> Dict:
        """Normalize OpenVAS findings"""
        return {
            'name': finding.get('name'),
            'description': finding.get('description', ''),
            'severity': self._map_openvas_severity(finding.get('severity')),
            'evidence': f"Port: {finding.get('port')} - Host: {finding.get('host')}",
            'source': 'openvas',
            'confidence': 'high',
            'type': 'network',
            'references': finding.get('cve', []),
            'metadata': {
                'original_source': 'openvas',
                'solution': finding.get('solution'),
                'port': finding.get('port'),
                'scan_date': datetime.now().isoformat()
            }
        }

    def _correlate_findings(self, findings: List[Dict]) -> List[Dict]:
        """Correlate and deduplicate findings"""
        correlated = {}
        
        for finding in findings:
            # Create a key for correlation
            key = f"{finding['name']}_{finding['type']}_{finding['severity']}"
            
            if key in correlated:
                existing = correlated[key]
                # Merge sources
                existing['sources'] = list(set(existing.get('sources', []) + [finding['source']]))
                # Merge references
                existing['references'] = list(set(existing.get('references', []) + finding['references']))
                # Take highest confidence
                existing['confidence'] = max(existing['confidence'], finding['confidence'])
                # Merge metadata
                existing['metadata'].update(finding['metadata'])
            else:
                finding['sources'] = [finding['source']]
                correlated[key] = finding

        return list(correlated.values())

    def _save_findings(self, findings: List[Dict], target: str) -> List[Dict]:
        """Save correlated findings to database"""
        saved_findings = []
        
        for finding in findings:
            vulnerability = Vulnerability.objects.create(
                target=target,
                name=finding['name'],
                description=finding['description'],
                severity=finding['severity'],
                vuln_type=finding['type'],
                evidence=finding['evidence'],
                source=','.join(finding['sources']),
                confidence=finding['confidence'],
                references=finding['references'],
                metadata=finding['metadata']
            )
            saved_findings.append(self._serialize_vulnerability(vulnerability))
            
        return saved_findings

    def _serialize_vulnerability(self, vuln: Vulnerability) -> Dict:
        """Serialize vulnerability for response"""
        return {
            'id': vuln.id,
            'name': vuln.name,
            'description': vuln.description,
            'severity': vuln.severity,
            'type': vuln.vuln_type,
            'evidence': vuln.evidence,
            'sources': vuln.source.split(','),
            'confidence': vuln.confidence,
            'discovery_date': vuln.discovery_date.isoformat(),
            'references': vuln.references,
            'metadata': vuln.metadata
        }

    def _map_zap_severity(self, severity: str) -> str:
        """Map ZAP severity to standard severity"""
        mapping = {
            'Informational': 'INFO',
            'Low': 'LOW',
            'Medium': 'MEDIUM',
            'High': 'HIGH',
            'Critical': 'CRITICAL'
        }
        return mapping.get(severity, 'LOW')

    def _map_openvas_severity(self, severity: str) -> str:
        """Map OpenVAS severity to standard severity"""
        try:
            severity_float = float(severity)
            if severity_float >= 9.0:
                return 'CRITICAL'
            elif severity_float >= 7.0:
                return 'HIGH'
            elif severity_float >= 4.0:
                return 'MEDIUM'
            elif severity_float > 0:
                return 'LOW'
            return 'INFO'
        except (ValueError, TypeError):
            return 'LOW'