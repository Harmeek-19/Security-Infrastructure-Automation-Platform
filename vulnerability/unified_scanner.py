from typing import Dict, List
import logging
from datetime import datetime
from .scanner import VulnerabilityScanner
from .zap_manager import ZAPManager
from .models import Vulnerability, NucleiFinding
from .nuclei_scanner import NucleiScanner
from .correlation import VulnerabilityCorrelator  # Import the enhanced correlator

class UnifiedVulnerabilityScanner:
    # Define valid scan types
    VALID_SCAN_TYPES = {
        'quick': 'Fast scan with basic checks',
        'standard': 'Standard comprehensive scan',
        'full': 'Full detailed scan with all checks'
    }

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.internal_scanner = VulnerabilityScanner()
        self.zap_manager = ZAPManager()
        self.correlator = VulnerabilityCorrelator()  # Initialize the correlator
        try:
            self.nuclei_scanner = NucleiScanner()
            self.logger.info("Successfully initialized Nuclei scanner")
        except Exception as e:
            self.logger.error(f"Failed to initialize Nuclei scanner: {str(e)}")
            self.nuclei_scanner = None
            # Don't raise the exception, just log it and continue with other scanners

    def validate_scan_type(self, scan_type: str) -> str:
        """Validate scan type and return normalized version"""
        if not scan_type:
            return 'standard'  # Default scan type
            
        normalized_type = scan_type.lower().strip()
        if normalized_type not in self.VALID_SCAN_TYPES:
            raise ValueError(
                f"Invalid scan type: '{scan_type}'. Valid types are: {list(self.VALID_SCAN_TYPES.keys())}"
            )
        return normalized_type

    def get_scan_types(self) -> Dict[str, str]:
        """Return available scan types and their descriptions"""
        return self.VALID_SCAN_TYPES

    def scan_target(self, target: str, scan_type: str = 'standard', 
                   include_zap: bool = True, include_nuclei: bool = True,
                   nuclei_scan_type: str = 'basic',
                   use_advanced_correlation: bool = True) -> Dict:
        """
        Perform a comprehensive scan using multiple scanners based on parameters
        """
        try:
            # Validate scan type first
            validated_scan_type = self.validate_scan_type(scan_type)
            
            results = {
                'target': target,
                'scan_start': datetime.now().isoformat(),
                'vulnerabilities': [],
                'scanners_used': ['internal'],
                'summary': {
                    'high': 0,
                    'medium': 0,
                    'low': 0,
                    'total': 0
                },
                'correlation': {}
            }

            # Track findings from each scanner for correlation
            internal_results = []
            zap_results = []
            nuclei_results = []

            # Run internal scanner with validated scan type
            self.logger.info(f"Starting internal scanner with scan type: {validated_scan_type}")
            internal_scan = self.internal_scanner.scan_target(target, validated_scan_type)
            
            if internal_scan.get('vulnerabilities'):
                internal_results = internal_scan['vulnerabilities']
                results['scanners_used'].append('internal')
                self.logger.info(f"Internal scanner found {len(internal_results)} vulnerabilities")

            # Run ZAP scan if requested
            if include_zap:
                self.logger.info("Starting ZAP scanner")
                if self.zap_manager.ensure_zap_running():
                    results['scanners_used'].append('zap')
                    zap_scan = self.zap_manager.run_scan(target)
                    if zap_scan.get('status') == 'success' and zap_scan.get('alerts'):
                        zap_results = zap_scan['alerts']
                        self.logger.info(f"ZAP scanner found {len(zap_results)} vulnerabilities")
                else:
                    self.logger.warning("ZAP scanner not available")

            # Run Nuclei scan if requested
            # In the scan_target method of UnifiedVulnerabilityScanner class:
            # Run Nuclei scan if requested
            if include_nuclei:
                if self.nuclei_scanner:
                    try:
                        self.logger.info(f"Starting Nuclei scan with type: {nuclei_scan_type}")
                        if nuclei_scan_type.lower() == 'advanced':
                            nuclei_scan = self.nuclei_scanner.run_advanced_scan(target)
                        else:
                            nuclei_scan = self.nuclei_scanner.run_basic_scan(target)
                        
                        if nuclei_scan.get('status') == 'success' and nuclei_scan.get('findings'):
                            results['scanners_used'].append('nuclei')
                            nuclei_results = nuclei_scan['findings']
                            self.logger.info(f"Nuclei scanner found {len(nuclei_results)} vulnerabilities")
                        else:
                            self.logger.warning(f"Nuclei scan completed but returned no findings or had an error: {nuclei_scan.get('error', 'No error specified')}")
                    except Exception as e:
                        self.logger.error(f"Nuclei scan failed: {str(e)}")
                        self.logger.error("Continuing with other scanners")
                else:
                    self.logger.warning("Nuclei scanner not available or failed to initialize")

            # Use enhanced correlation if enabled
            if use_advanced_correlation:
                self.logger.info("Using advanced correlation for findings")
                correlation_result = self.correlator.correlate_findings(
                    internal_results=internal_results,
                    zap_results=zap_results,
                    nuclei_results=nuclei_results,
                    target=target
                )
                
                if correlation_result.get('status') == 'success':
                    results['vulnerabilities'] = correlation_result.get('findings', [])
                    results['correlation'] = {
                        'original_count': correlation_result.get('original_count', 0),
                        'correlated_count': correlation_result.get('correlated_count', 0),
                        'reduction_percentage': correlation_result.get('statistics', {}).get('reduction_percentage', 0),
                        'stats': correlation_result.get('statistics', {})
                    }
                    self.logger.info(f"Correlation reduced findings from {correlation_result.get('original_count', 0)} to {correlation_result.get('correlated_count', 0)}")
                else:
                    # Fallback to basic processing if correlation failed
                    self.logger.warning("Advanced correlation failed, falling back to basic processing")
                    self._process_scanner_results(results, internal_results, zap_results, nuclei_results)
            else:
                # Use basic processing
                self.logger.info("Using basic processing for findings")
                self._process_scanner_results(results, internal_results, zap_results, nuclei_results)
            
            # Update summary
            self._update_summary(results)
            
            # Add scan configuration to results
            results['scan_config'] = {
                'scan_type': validated_scan_type,
                'scanners': {
                    'internal': True,
                    'zap': include_zap,
                    'nuclei': {
                        'enabled': include_nuclei,
                        'type': nuclei_scan_type if include_nuclei else 'disabled'
                    }
                },
                'correlation': {
                    'advanced': use_advanced_correlation
                }
            }
            
            results['scan_end'] = datetime.now().isoformat()
            results['status'] = 'success'
            
            # Deduplicate vulnerabilities
            deduplication_stats = Vulnerability.deduplicate_vulnerabilities(target)
            
            # Add deduplication stats to results
            results['deduplication_stats'] = deduplication_stats
            
            return results

        except ValueError as e:
            # Handle validation errors
            error_msg = str(e)
            self.logger.error(f"Validation error: {error_msg}")
            return {
                'status': 'error',
                'error': error_msg,
                'valid_scan_types': list(self.VALID_SCAN_TYPES.keys())
            }
        except Exception as e:
            self.logger.error(f"Unified scan failed: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }
            
    def _process_scanner_results(self, results: Dict, internal_results: List, 
                                zap_results: List, nuclei_results: List) -> None:
        """Process results from different scanners using basic approach"""
        # Process internal scanner results
        for vuln in internal_results:
            results['vulnerabilities'].append({
                'source': 'internal',
                'name': vuln.get('name', ''),
                'description': vuln.get('description', ''),
                'severity': vuln.get('severity', 'LOW'),
                'type': vuln.get('type', ''),
                'evidence': vuln.get('evidence', ''),
                'confidence': vuln.get('confidence', 'medium'),
                'cvss_score': vuln.get('cvss', 0.0)
            })

        # Process ZAP scanner results
        for alert in zap_results:
            results['vulnerabilities'].append({
                'source': 'zap',
                'name': alert.get('name', ''),
                'description': alert.get('description', ''),
                'severity': self._normalize_severity(alert.get('risk')),
                'type': 'web',
                'evidence': alert.get('evidence', ''),
                'confidence': alert.get('confidence', 'medium'),
                'solution': alert.get('solution', ''),
                'cwe': alert.get('cweid', ''),
                'metadata': {
                    'url': alert.get('url', ''),
                    'parameter': alert.get('parameter', '')
                }
            })

        # Process Nuclei scanner results
        for finding in nuclei_results:
            results['vulnerabilities'].append({
                'source': 'nuclei',
                'name': finding.get('name', ''),
                'description': finding.get('description', ''),
                'severity': finding.get('severity', 'LOW'),
                'type': finding.get('type', 'nuclei'),
                'evidence': finding.get('evidence', ''),
                'confidence': 'high',
                'cvss_score': finding.get('cvss_score', 0.0),
                'cwe': finding.get('cwe', ''),
                'references': finding.get('references', []),
                'metadata': {
                    'template_id': finding.get('template_id', ''),
                    'tags': finding.get('tags', []),
                    'matched_at': finding.get('matched', ''),
                    'host': finding.get('host', '')
                }
            })
        
        # Basic deduplication by name and severity
        results['vulnerabilities'] = self._basic_deduplicate(results['vulnerabilities'])
        
    def _basic_deduplicate(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Simple deduplication of vulnerabilities by name and severity"""
        unique_vulns = {}
        
        for vuln in vulnerabilities:
            # Create a key for deduplication
            key = f"{vuln['name']}_{vuln['severity']}"
            
            if key in unique_vulns:
                existing = unique_vulns[key]
                # Merge sources
                sources = set([existing['source']])
                sources.add(vuln['source'])
                existing['source'] = ','.join(sources)
                # Take highest confidence
                if vuln.get('confidence') == 'high':
                    existing['confidence'] = 'high'
            else:
                unique_vulns[key] = vuln
                
        return list(unique_vulns.values())

    def _normalize_severity(self, severity: str) -> str:
        """Normalize severity ratings across different scanners"""
        severity = str(severity).lower()
        
        if severity in ['critical', 'high', '3', '4']:
            return 'HIGH'
        elif severity in ['medium', 'warning', '2']:
            return 'MEDIUM'
        elif severity in ['low', 'info', '1']:
            return 'LOW'
        return 'INFO'

    def _update_summary(self, results: Dict) -> None:
        """Update the summary counts"""
        summary = {'high': 0, 'medium': 0, 'low': 0, 'total': 0}
        
        for vuln in results['vulnerabilities']:
            severity = vuln['severity'].lower()
            if severity in summary:
                summary[severity] += 1
            summary['total'] += 1

        results['summary'] = summary

    def get_scanner_status(self) -> Dict:
        """Get status of all scanners"""
        status = {
            'internal': {
                'status': 'available',
                'checks': list(self.internal_scanner.checks.keys())
            },
            'zap': self.zap_manager.get_status()
        }

        # Add Nuclei status if initialized
        if self.nuclei_scanner:
            try:
                nuclei_info = self.nuclei_scanner.get_template_info()
                status['nuclei'] = {
                    'status': 'available',
                    'templates': nuclei_info.get('total_templates', 0),
                    'template_types': nuclei_info.get('template_types', {})
                }
            except Exception as e:
                status['nuclei'] = {
                    'status': 'error',
                    'error': str(e)
                }

        return status

    def _save_findings(self, vulnerabilities: List[Dict], target: str) -> None:
        """Save findings to database"""
        for vuln in vulnerabilities:
            # Extract metadata
            metadata = {
                'url': vuln.get('url'),
                'parameter': vuln.get('parameter'),
                'extra_info': vuln.get('metadata', {})
            }
            
            try:
                Vulnerability.objects.create(
                    target=target,
                    name=vuln['name'],
                    description=vuln.get('description', ''),
                    severity=vuln['severity'],
                    vuln_type=vuln.get('type', 'unknown'),
                    evidence=vuln.get('evidence', ''),
                    source=vuln['source'],
                    confidence=vuln['confidence'],
                    solution=vuln.get('solution', ''),
                    cwe=vuln.get('cwe', ''),
                    cvss_score=vuln.get('cvss_score'),
                    references=vuln.get('references', []),
                    metadata=metadata
                )
            except Exception as e:
                self.logger.error(f"Error saving vulnerability: {str(e)}")
                self.logger.error(f"Vulnerability data: {vuln}")