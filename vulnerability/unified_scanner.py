from typing import Dict, List, Optional
import logging
from datetime import datetime
from .scanner import VulnerabilityScanner
from .scanner_integration import ScannerIntegration
from .models import Vulnerability

class UnifiedVulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.internal_scanner = VulnerabilityScanner()
        self.zap_integration = ScannerIntegration()
        
        # Initialize ZAP scanner
        self.zap_available = self.zap_integration.initialize_scanners()
        if not self.zap_available:
            self.logger.warning("ZAP scanner initialization failed")

    def scan_target(self, target: str, scan_type: str = 'standard', include_zap: bool = True) -> Dict:
        """
        Perform a comprehensive scan using both internal scanner and ZAP
        """
        results = {
            'target': target,
            'scan_start': datetime.now().isoformat(),
            'vulnerabilities': [],
            'scanners_used': ['internal'],
            'summary': {
                'high': 0,
                'medium': 0,
                'low': 0,
                'total': 0
            }
        }

        try:
            # Run internal scanner
            internal_results = self.internal_scanner.scan_target(target)
            self._process_internal_results(results, internal_results)

            # Run ZAP scan if available and requested
            if self.zap_available and include_zap:
                results['scanners_used'].append('zap')
                zap_results = self.zap_integration.run_zap_scan(target)
                self._process_zap_results(results, zap_results)

            # Deduplicate and correlate findings
            results['vulnerabilities'] = self._correlate_vulnerabilities(results['vulnerabilities'])
            
            # Update final summary
            self._update_summary(results)
            
            results['scan_end'] = datetime.now().isoformat()
            results['status'] = 'success'
            
            return results

        except Exception as e:
            self.logger.error(f"Unified scan failed: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'scan_end': datetime.now().isoformat()
            }

    def _process_internal_results(self, results: Dict, internal_results: Dict) -> None:
        """Process results from internal scanner"""
        if internal_results.get('vulnerabilities'):
            for vuln in internal_results['vulnerabilities']:
                processed_vuln = {
                    'source': 'internal',
                    'name': vuln.get('name', ''),
                    'description': vuln.get('description', ''),
                    'severity': vuln.get('severity', 'LOW'),
                    'type': vuln.get('type', ''),
                    'evidence': vuln.get('evidence', ''),
                    'confidence': vuln.get('confidence', 'medium'),
                    'cvss_score': vuln.get('cvss', 0.0)
                }
                results['vulnerabilities'].append(processed_vuln)

    def _process_zap_results(self, results: Dict, zap_results: Dict) -> None:
        """Process results from ZAP scanner"""
        if zap_results.get('alerts'):
            for alert in zap_results['alerts']:
                processed_vuln = self.zap_integration._process_zap_vulnerability(alert)
                results['vulnerabilities'].append(processed_vuln)

    def _correlate_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Correlate and deduplicate findings from different scanners"""
        correlated = {}
        
        for vuln in vulnerabilities:
            # Create a key for correlation
            key = f"{vuln['name']}_{vuln['severity']}"
            
            if key in correlated:
                # Merge evidence and sources
                existing = correlated[key]
                existing['sources'] = list(set(existing.get('sources', []) + [vuln['source']]))
                existing['evidence'] = f"{existing['evidence']}\n\nAdditional Evidence ({vuln['source']}):\n{vuln['evidence']}"
                
                # Take the highest confidence and CVSS score
                existing['confidence'] = max(existing['confidence'], vuln['confidence'])
                existing['cvss_score'] = max(existing.get('cvss_score', 0), vuln.get('cvss_score', 0))
            else:
                vuln['sources'] = [vuln['source']]
                correlated[key] = vuln

        return list(correlated.values())

    def _update_summary(self, results: Dict) -> None:
        """Update the summary counts of vulnerabilities"""
        summary = {'high': 0, 'medium': 0, 'low': 0, 'total': 0}
        
        for vuln in results['vulnerabilities']:
            severity = vuln['severity'].lower()
            if severity in summary:
                summary[severity] += 1
            summary['total'] += 1

        results['summary'] = summary

    def get_scanner_status(self) -> Dict:
        """Get status of all configured scanners"""
        status = {
            'internal': {
                'status': 'available',
                'checks': list(self.internal_scanner.checks.keys())
            }
        }
        
        if self.zap_available:
            zap_status = self.zap_integration.get_scanner_status()
            status['zap'] = zap_status.get('zap', {'status': 'unavailable'})
            
        return status