import subprocess
import json
import logging
import os
import re
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from datetime import datetime
from django.conf import settings

class NucleiScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Define Nuclei paths
        self.go_path = str(Path.home() / "go")  # More reliable GOPATH
        self.nuclei_path = os.path.join(self.go_path, "bin", "nuclei")
        self.logger.info(f"Using Nuclei at: {self.nuclei_path}")
        
        # Set up directories
        self.base_dir = Path(settings.BASE_DIR)
        self.results_dir = self.base_dir / "vulnerability" / "nuclei-results"
        self.debug_dir = self.base_dir / "vulnerability" / "debug_logs"
        
        # Create directories if they don't exist
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.debug_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up environment with Go paths
        self.env = os.environ.copy()
        self.env["PATH"] = f"{self.go_path}/bin:{self.env.get('PATH', '')}"
        self.env["GOPATH"] = self.go_path
        
        # Verify installation
        if not self._verify_nuclei_installation():
            error_msg = (
                "Nuclei not found. Please install using:\n"
                "1. go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest\n"
                f"2. Verify installation at: {self.nuclei_path}"
            )
            raise Exception(error_msg)

    def _verify_nuclei_installation(self) -> bool:
        """Verify Nuclei is installed and working"""
        try:
            result = subprocess.run(
                [self.nuclei_path, '-version'],
                capture_output=True,
                text=True,
                env=self.env,
                timeout=10
            )
            
            if result.stderr and 'INF' in result.stderr:
                version_line = result.stderr.splitlines()[0] if result.stderr.splitlines() else "Unknown version"
                self.logger.info(f"Nuclei version verified: {version_line}")
                if "outdated" in result.stderr:
                    self.logger.warning("Nuclei is outdated. Consider updating for better results.")
            
            # Update templates if needed
            self.update_templates()
            
            return result.returncode == 0
        except Exception as e:
            self.logger.error(f"Error verifying nuclei: {str(e)}")
            return False

    def scan_target(self, target: str, scan_options: Optional[Dict] = None, 
                additional_flags: Optional[List[str]] = None, timeout: int = 300) -> Dict:
        """Core scanning method used by both basic and advanced scans"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            
            self.logger.info(f"Starting Nuclei scan {scan_id} for target: {target}")
            
            # Build base command
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-stats",           # Show statistics
                "-duc",            # Disable update check
                "-no-color",        # No color output
                "-silent"           # Reduce output verbosity
            ]

            # Add templates path
            templates_path = str(Path.home() / "nuclei-templates" / "http" / "vulnerabilities")
            cmd.extend(["-t", templates_path])

            # Add severity levels
            cmd.extend(["-severity", "critical,high,medium,low"])

            # Add any additional flags
            if additional_flags:
                cmd.extend(additional_flags)

            # Log command to debug file instead of console
            debug_log_file = self.debug_dir / f"nuclei_cmd_{scan_id}.log"
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
            
            # Run the scan
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=timeout
            )
            
            # Log stderr and stdout to debug file instead of console
            if process.stderr or process.stdout:
                with open(debug_log_file, 'a') as f:
                    if process.stderr:
                        f.write(f"\nSTDERR:\n{process.stderr}\n")
                    if process.stdout:
                        f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings instead of each individual finding
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def run_basic_scan(self, target: str) -> Dict:
        """Run a basic vulnerability scan using auto-scan mode"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            
            self.logger.info(f"Starting basic Nuclei scan for {target}")
            
            # Simple, effective command based on working example
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-as",              # Automatic scan mode
                "-stats",           # Show statistics
                "-silent"           # Reduce output verbosity
            ]

            # Log command to debug file instead of console
            debug_log_file = self.debug_dir / f"nuclei_basic_{scan_id}.log"
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
            
            # Run the scan
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=300
            )
            
            # Log stderr and stdout to debug file instead of console
            if process.stderr or process.stdout:
                with open(debug_log_file, 'a') as f:
                    if process.stderr:
                        f.write(f"\nSTDERR:\n{process.stderr}\n")
                    if process.stdout:
                        f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings instead of each individual finding
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Basic Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "raw_output_file": str(debug_log_file),  # Reference to raw output file instead of including in response
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during basic Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def run_advanced_scan(self, target: str, options: Optional[Dict] = None) -> Dict:
        """Run a more comprehensive scan with additional options"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            
            self.logger.info(f"Starting advanced Nuclei scan for {target}")
            
            # Extended command with additional options
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-as",              # Automatic scan mode
                "-stats",           # Show statistics
                "-c", "50",         # Increased concurrency
                "-timeout", "15",   # Extended timeout
                "-retries", "2",    # Retry failed requests
                "-silent"           # Reduce output verbosity
            ]

            # Log command to debug file instead of console
            debug_log_file = self.debug_dir / f"nuclei_advanced_{scan_id}.log"
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
            
            # Run the scan with longer timeout
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=600  # 10 minutes
            )
            
            # Log stderr and stdout to debug file instead of console
            if process.stderr or process.stdout:
                with open(debug_log_file, 'a') as f:
                    if process.stderr:
                        f.write(f"\nSTDERR:\n{process.stderr}\n")
                    if process.stdout:
                        f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings instead of each individual finding
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Advanced Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "raw_output_file": str(debug_log_file),  # Reference to raw output file instead of including in response
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during advanced Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def _process_findings(self, findings: List[Dict]) -> List[Dict]:
        """Process and normalize Nuclei findings with CVSS handling"""
        processed = []
        
        # Severity to CVSS base mapping
        severity_cvss = {
            'CRITICAL': 9.5,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'INFO': 0.0,
            'unknown': 0.0
        }

        for finding in findings:
            try:
                # Get info block
                info = finding.get("info", {})
                if not info and "name" in finding:
                    info = finding

                # Extract matched data
                matched_data = ""
                if "matcher-name" in finding:
                    matched_data = f"Matcher: {finding['matcher-name']}"
                if "matched-at" in finding:
                    matched_data += f"\nMatched at: {finding['matched-at']}"
                if "extracted-results" in finding:
                    matched_data += f"\nExtracted: {finding['extracted-results']}"

                # Determine CVSS score
                cvss_score = None
                if 'classification' in info and 'cvss-score' in info['classification']:
                    try:
                        cvss_score = float(info['classification']['cvss-score'])
                    except (ValueError, TypeError):
                        # Use severity-based score if CVSS parse fails
                        severity = info.get('severity', 'unknown').upper()
                        cvss_score = severity_cvss.get(severity, 0.0)
                else:
                    # Use severity-based score if no CVSS provided
                    severity = info.get('severity', 'unknown').upper()
                    cvss_score = severity_cvss.get(severity, 0.0)

                processed.append({
                    "template_id": finding.get("template-id", ""),
                    "name": info.get("name", "Unknown Finding"),
                    "severity": info.get("severity", "unknown").upper(),
                    "type": finding.get("type", "unknown"),
                    "host": finding.get("host", ""),
                    "matched": finding.get("matched-at", ""),
                    "evidence": matched_data,
                    "description": info.get("description", ""),
                    "tags": info.get("tags", []),
                    "references": info.get("reference", []),
                    "cwe": info.get("classification", {}).get("cwe-id", ""),
                    "cvss_score": cvss_score,
                    "timestamp": finding.get("timestamp", datetime.now().isoformat())
                })
            except Exception as e:
                self.logger.error(f"Error processing finding: {str(e)}")

        return processed

    def _generate_summary(self, findings: List[Dict]) -> Dict:
        """Generate summary of findings"""
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for finding in findings:
            severity = finding.get("severity", "").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts["info"] += 1

        return {
            "total_findings": len(findings),
            "severity_distribution": severity_counts,
            "unique_templates": len(set(f.get("template_id", "") for f in findings))
        }

    def update_templates(self) -> Dict:
        """Update Nuclei templates"""
        try:
            cmd = [self.nuclei_path, "-update-templates", "-silent"]
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=180
            )
            
            if process.returncode != 0:
                return {
                    "status": "error",
                    "error": process.stderr or "Template update failed"
                }

            return {
                "status": "success",
                "message": "Templates updated successfully"
            }

        except Exception as e:
            self.logger.error(f"Error updating templates: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def get_template_info(self) -> Dict:
        """Get information about available templates"""
        try:
            cmd = [self.nuclei_path, "-tl", "-silent"]
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=60
            )
            
            if process.returncode != 0:
                return {
                    "status": "error",
                    "error": process.stderr or "Failed to get template list"
                }

            templates = process.stdout.strip().split("\n")
            template_count = len(templates)
            
            template_types = {
                "cve": 0,
                "vulnerability": 0,
                "exposure": 0,
                "technology": 0,
                "misconfiguration": 0,
                "default-login": 0,
                "other": 0
            }
            
            for template in templates:
                template_lower = template.lower()
                if "cve" in template_lower:
                    template_types["cve"] += 1
                elif "vuln" in template_lower:
                    template_types["vulnerability"] += 1
                elif "exposure" in template_lower:
                    template_types["exposure"] += 1
                elif "tech" in template_lower:
                    template_types["technology"] += 1
                elif "misconfig" in template_lower:
                    template_types["misconfiguration"] += 1
                elif "default" in template_lower and "login" in template_lower:
                    template_types["default-login"] += 1
                else:
                    template_types["other"] += 1
            
            return {
                "status": "success",
                "total_templates": template_count,
                "template_types": template_types,
                "templates": templates[:50],
                "note": "Response limited to 50 templates" if template_count > 50 else ""
            }

        except Exception as e:
            self.logger.error(f"Error getting template info: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }