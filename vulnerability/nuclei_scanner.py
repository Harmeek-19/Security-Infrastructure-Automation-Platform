import subprocess
import json
import logging
import os
import re
import shutil
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from datetime import datetime
from django.conf import settings

class NucleiScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Define Nuclei paths with better error handling
        self.go_path = str(Path.home() / "go")  # More reliable GOPATH
        
        # Try to find nuclei binary in multiple locations
        self.nuclei_path = self._find_nuclei_binary()
        self.logger.info(f"Using Nuclei at: {self.nuclei_path}")
        
        # Set up directories with explicit creation
        self.base_dir = Path(settings.BASE_DIR)
        self.results_dir = self.base_dir / "vulnerability" / "nuclei-results"
        self.debug_dir = self.base_dir / "vulnerability" / "debug_logs"
        
        # Create directories if they don't exist
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.debug_dir.mkdir(parents=True, exist_ok=True)
        
        # Set up environment with Go paths
        self.env = os.environ.copy()
        self.env["PATH"] = f"{self.go_path}/bin:{self.env.get('PATH', '')}"
        self.env["GOPATH"] = self.go_path
        
        # Verify installation
        if not self._verify_nuclei_installation():
            error_msg = (
                "Nuclei not found. Please install using:\n"
                "1. go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest\n"
                f"2. Verify installation at: {self.nuclei_path}"
            )
            raise Exception(error_msg)

    def _find_nuclei_binary(self) -> str:
        """Find the nuclei binary in various possible locations"""
        possible_locations = [
            str(Path.home() / "go" / "bin" / "nuclei"),  # Default Go installation
            "/usr/local/bin/nuclei",                     # Common system location
            "/usr/bin/nuclei",                          # Alternative system location
            str(Path(settings.BASE_DIR) / "bin" / "nuclei")  # Project-specific location
        ]
        
        # First check if nuclei is in PATH
        try:
            which_result = subprocess.run(["which", "nuclei"], capture_output=True, text=True)
            if which_result.returncode == 0 and which_result.stdout.strip():
                return which_result.stdout.strip()
        except Exception:
            pass  # Continue with other checks if 'which' fails
        
        # Check each possible location
        for location in possible_locations:
            if os.path.isfile(location) and os.access(location, os.X_OK):
                return location
        
        # Default to the standard location even if it doesn't exist yet
        return str(Path.home() / "go" / "bin" / "nuclei")

    def _verify_nuclei_installation(self) -> bool:
        """Verify Nuclei is installed and working"""
        try:
            result = subprocess.run(
                [self.nuclei_path, '-version'],
                capture_output=True,
                text=True,
                env=self.env,
                timeout=10
            )
            
            if result.stderr and 'INF' in result.stderr:
                version_line = result.stderr.splitlines()[0] if result.stderr.splitlines() else "Unknown version"
                self.logger.info(f"Nuclei version verified: {version_line}")
                if "outdated" in result.stderr:
                    self.logger.warning("Nuclei is outdated. Consider updating for better results.")
            
            # Update templates if needed
            try:
                self.update_templates()
            except Exception as e:
                self.logger.warning(f"Templates update failed but continuing: {str(e)}")
            
            return result.returncode == 0
        except Exception as e:
            self.logger.error(f"Error verifying nuclei: {str(e)}")
            return False

    def scan_target(self, target: str, scan_options: Optional[Dict] = None, 
                additional_flags: Optional[List[str]] = None, timeout: int = 300) -> Dict:
        """Core scanning method used by both basic and advanced scans"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            
            self.logger.info(f"Starting Nuclei scan {scan_id} for target: {target}")
            
            # Build base command
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-stats",           # Show statistics
                "-duc",            # Disable update check
                "-no-color",        # No color output
                "-silent"           # Reduce output verbosity
            ]

            # Add templates path if auto-scan not supported
            if not self._check_as_flag_support():
                templates_path = self._get_templates_path()
                if templates_path:
                    cmd.extend(["-t", templates_path])
                else:
                    templates_path = str(Path.home() / "nuclei-templates" / "http" / "vulnerabilities")
                    cmd.extend(["-t", templates_path])
                    
                # Add severity levels
                cmd.extend(["-severity", "critical,high,medium,low"])

            # Add any additional flags
            if additional_flags:
                cmd.extend(additional_flags)

            # Log command to debug file instead of console
            debug_log_file = self.debug_dir / f"nuclei_cmd_{scan_id}.log"
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
            
            # Run the scan
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=timeout
            )
            
            # Log stderr and stdout to debug file instead of console
            if process.stderr or process.stdout:
                with open(debug_log_file, 'a') as f:
                    if process.stderr:
                        f.write(f"\nSTDERR:\n{process.stderr}\n")
                    if process.stdout:
                        f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings instead of each individual finding
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def _check_as_flag_support(self) -> bool:
        """Check if -as flag (auto scan) is supported in this nuclei version"""
        try:
            help_output = subprocess.run(
                [self.nuclei_path, "-help"],
                capture_output=True,
                text=True,
                env=self.env,
                timeout=5
            )
            return "-as" in (help_output.stdout or "") or "-as" in (help_output.stderr or "")
        except Exception:
            return False

    def _get_templates_path(self) -> Optional[str]:
        """Find valid nuclei templates directory"""
        # Try standard location first
        home_templates = str(Path.home() / "nuclei-templates")
        if os.path.isdir(home_templates):
            return home_templates
            
        # Try specific vulnerability templates
        vuln_templates = str(Path.home() / "nuclei-templates" / "http" / "vulnerabilities")
        if os.path.isdir(vuln_templates):
            return vuln_templates
            
        # Check if templates are in the project directory
        project_templates = str(Path(settings.BASE_DIR) / "nuclei-templates")
        if os.path.isdir(project_templates):
            return project_templates
            
        return None

    def run_basic_scan(self, target: str) -> Dict:
        """Run a basic vulnerability scan using auto-scan mode with improved error handling"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"nuclei_basic_scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            debug_log_file = self.debug_dir / f"{scan_id}.log"
            
            self.logger.info(f"Starting basic Nuclei scan for {target}")
            
            # Check if auto-scan is supported
            as_flag_supported = self._check_as_flag_support()
            
            # Build command
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-stats",           # Show statistics
                "-silent"           # Reduce output verbosity
            ]
            
            # Add auto-scan mode if available, otherwise use templates
            if as_flag_supported:
                cmd.extend(["-as"])  # Automatic scan mode
            else:
                templates_path = self._get_templates_path()
                if templates_path:
                    cmd.extend(["-t", templates_path])
                    cmd.extend(["-severity", "critical,high,medium,low"])
                else:
                    self.logger.warning("No templates path found, scan may not work properly")
                    cmd.extend(["-t", "http"])  # Fallback to built-in http templates

            # Log command to debug file
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
                f.write(f"Auto-scan mode supported: {as_flag_supported}\n")
                f.write(f"Templates path: {self._get_templates_path() or 'Not found'}\n")
            
            # Run the scan with timeout
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=300
            )
            
            # Log stderr and stdout to debug file
            with open(debug_log_file, 'a') as f:
                if process.stderr:
                    f.write(f"\nSTDERR:\n{process.stderr}\n")
                if process.stdout:
                    f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Basic Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "raw_output_file": str(debug_log_file),
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during basic Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def run_advanced_scan(self, target: str, options: Optional[Dict] = None) -> Dict:
        """Run a more comprehensive scan with additional options"""
        try:
            # Clean target URL
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            # Generate scan ID and output file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = re.sub(r'[^\w\-_]', '_', target)
            scan_id = f"nuclei_advanced_scan_{timestamp}_{safe_target}"
            output_file = self.results_dir / f"{scan_id}.json"
            
            self.logger.info(f"Starting advanced Nuclei scan for {target}")
            
            # Extended command with additional options
            cmd = [
                self.nuclei_path,
                "-target", target,
                "-j",               # JSON output
                "-o", str(output_file),
                "-stats",           # Show statistics
                "-c", "50",         # Increased concurrency
                "-timeout", "15",   # Extended timeout
                "-retries", "2",    # Retry failed requests
                "-silent"           # Reduce output verbosity
            ]
            
            # Add auto-scan if supported, otherwise use templates
            as_flag_supported = self._check_as_flag_support()
            if as_flag_supported:
                cmd.extend(["-as"])  # Automatic scan mode
            else:
                templates_path = self._get_templates_path()
                if templates_path:
                    cmd.extend(["-t", templates_path])
                    cmd.extend(["-severity", "critical,high,medium,low"])
                else:
                    cmd.extend(["-t", "http"])  # Fallback to built-in http templates

            # Log command to debug file instead of console
            debug_log_file = self.debug_dir / f"{scan_id}.log"
            with open(debug_log_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
                f.write(f"Auto-scan mode supported: {as_flag_supported}\n")
                f.write(f"Templates path: {self._get_templates_path() or 'Not found'}\n")
            
            # Run the scan with longer timeout
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=600  # 10 minutes
            )
            
            # Log stderr and stdout to debug file
            with open(debug_log_file, 'a') as f:
                if process.stderr:
                    f.write(f"\nSTDERR:\n{process.stderr}\n")
                if process.stdout:
                    f.write(f"\nSTDOUT:\n{process.stdout}\n")
            
            # Process results
            findings = []
            if output_file.exists():
                try:
                    with open(output_file) as f:
                        content = f.read().strip()
                        if content:
                            for line in content.split('\n'):
                                try:
                                    if line.strip():
                                        finding = json.loads(line)
                                        findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                except Exception as e:
                    self.logger.error(f"Error reading output file: {str(e)}")

            processed_findings = self._process_findings(findings)
            
            # Log summary of findings
            summary = self._generate_summary(processed_findings)
            self.logger.info(f"Advanced Nuclei scan complete: {summary['total_findings']} findings ({', '.join([f'{sev}: {count}' for sev, count in summary['severity_distribution'].items() if count > 0])})")
            
            return {
                "status": "success",
                "target": target,
                "scan_id": scan_id,
                "timestamp": datetime.now().isoformat(),
                "findings": processed_findings,
                "raw_output_file": str(debug_log_file),
                "summary": summary
            }

        except Exception as e:
            self.logger.error(f"Error during advanced Nuclei scan: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def _process_findings(self, findings: List[Dict]) -> List[Dict]:
        """Process and normalize Nuclei findings with CVSS handling"""
        processed = []
        
        # Severity to CVSS base mapping
        severity_cvss = {
            'CRITICAL': 9.5,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'INFO': 0.0,
            'unknown': 0.0
        }

        for finding in findings:
            try:
                # Get info block
                info = finding.get("info", {})
                if not info and "name" in finding:
                    info = finding

                # Extract matched data
                matched_data = ""
                if "matcher-name" in finding:
                    matched_data = f"Matcher: {finding['matcher-name']}"
                if "matched-at" in finding:
                    matched_data += f"\nMatched at: {finding['matched-at']}"
                if "extracted-results" in finding:
                    matched_data += f"\nExtracted: {finding['extracted-results']}"

                # Determine CVSS score
                cvss_score = None
                if 'classification' in info and 'cvss-score' in info['classification']:
                    try:
                        cvss_score = float(info['classification']['cvss-score'])
                    except (ValueError, TypeError):
                        # Use severity-based score if CVSS parse fails
                        severity = info.get('severity', 'unknown').upper()
                        cvss_score = severity_cvss.get(severity, 0.0)
                else:
                    # Use severity-based score if no CVSS provided
                    severity = info.get('severity', 'unknown').upper()
                    cvss_score = severity_cvss.get(severity, 0.0)

                processed.append({
                    "template_id": finding.get("template-id", ""),
                    "name": info.get("name", "Unknown Finding"),
                    "severity": info.get("severity", "unknown").upper(),
                    "type": finding.get("type", "unknown"),
                    "host": finding.get("host", ""),
                    "matched": finding.get("matched-at", ""),
                    "evidence": matched_data,
                    "description": info.get("description", ""),
                    "tags": info.get("tags", []),
                    "references": info.get("reference", []),
                    "cwe": info.get("classification", {}).get("cwe-id", ""),
                    "cvss_score": cvss_score,
                    "timestamp": finding.get("timestamp", datetime.now().isoformat())
                })
            except Exception as e:
                self.logger.error(f"Error processing finding: {str(e)}")

        return processed

    def _generate_summary(self, findings: List[Dict]) -> Dict:
        """Generate summary of findings"""
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for finding in findings:
            severity = finding.get("severity", "").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts["info"] += 1

        return {
            "total_findings": len(findings),
            "severity_distribution": severity_counts,
            "unique_templates": len(set(f.get("template_id", "") for f in findings))
        }

    def update_templates(self) -> Dict:
        """Update Nuclei templates"""
        try:
            cmd = [self.nuclei_path, "-update-templates", "-silent"]
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=180
            )
            
            if process.returncode != 0:
                return {
                    "status": "error",
                    "error": process.stderr or "Template update failed"
                }

            return {
                "status": "success",
                "message": "Templates updated successfully"
            }

        except Exception as e:
            self.logger.error(f"Error updating templates: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }

    def get_template_info(self) -> Dict:
        """Get information about available templates"""
        try:
            cmd = [self.nuclei_path, "-tl", "-silent"]
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                env=self.env,
                timeout=60
            )
            
            if process.returncode != 0:
                return {
                    "status": "error",
                    "error": process.stderr or "Failed to get template list"
                }

            templates = process.stdout.strip().split("\n")
            template_count = len(templates)
            
            template_types = {
                "cve": 0,
                "vulnerability": 0,
                "exposure": 0,
                "technology": 0,
                "misconfiguration": 0,
                "default-login": 0,
                "other": 0
            }
            
            for template in templates:
                template_lower = template.lower()
                if "cve" in template_lower:
                    template_types["cve"] += 1
                elif "vuln" in template_lower:
                    template_types["vulnerability"] += 1
                elif "exposure" in template_lower:
                    template_types["exposure"] += 1
                elif "tech" in template_lower:
                    template_types["technology"] += 1
                elif "misconfig" in template_lower:
                    template_types["misconfiguration"] += 1
                elif "default" in template_lower and "login" in template_lower:
                    template_types["default-login"] += 1
                else:
                    template_types["other"] += 1
            
            return {
                "status": "success",
                "total_templates": template_count,
                "template_types": template_types,
                "templates": templates[:50],
                "note": "Response limited to 50 templates" if template_count > 50 else ""
            }

        except Exception as e:
            self.logger.error(f"Error getting template info: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }
            
    def diagnose(self) -> Dict:
        """Run diagnostics to troubleshoot Nuclei scanner issues"""
        try:
            # Check nuclei binary
            binary_exists = os.path.exists(self.nuclei_path)
            binary_executable = os.access(self.nuclei_path, os.X_OK) if binary_exists else False
            
            # Check directories
            results_dir_exists = self.results_dir.exists()
            results_dir_writable = os.access(str(self.results_dir), os.W_OK) if results_dir_exists else False
            debug_dir_exists = self.debug_dir.exists()
            debug_dir_writable = os.access(str(self.debug_dir), os.W_OK) if debug_dir_exists else False
            
            # Check templates
            templates_path = self._get_templates_path()
            templates_exist = templates_path is not None
            as_flag_supported = self._check_as_flag_support()
            
            # Try version check
            version_info = {}
            try:
                result = subprocess.run(
                    [self.nuclei_path, '-version'],
                    capture_output=True,
                    text=True,
                    env=self.env,
                    timeout=10
                )
                version_info = {
                    "success": result.returncode == 0,
                    "stdout": result.stdout,
                    "stderr": result.stderr,
                    "returncode": result.returncode
                }
            except Exception as e:
                version_info = {
                    "success": False,
                    "error": str(e)
                }
            
            return {
                "status": "success",
                "binary": {
                    "path": self.nuclei_path,
                    "exists": binary_exists,
                    "executable": binary_executable
                },
                "directories": {
                    "results_dir": {
                        "path": str(self.results_dir),
                        "exists": results_dir_exists,
                        "writable": results_dir_writable
                    },
                    "debug_dir": {
                        "path": str(self.debug_dir),
                        "exists": debug_dir_exists,
                        "writable": debug_dir_writable
                    }
                },
                "templates": {
                    "path": templates_path,
                    "exists": templates_exist,
                    "auto_scan_supported": as_flag_supported
                },
                "version_check": version_info,
                "environment": {
                    "gopath": self.go_path,
                    "path": self.env.get("PATH", "")
                }
            }
        except Exception as e:
            self.logger.error(f"Error running diagnostics: {str(e)}")
            return {
                "status": "error",
                "error": str(e)
            }