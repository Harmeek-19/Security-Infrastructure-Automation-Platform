# vulnerability/scanner.py
import requests
import socket
import ssl
from typing import List, Dict
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse
import warnings
from datetime import datetime
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

class VulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Available vulnerability checks
        self.checks = {
            'http': self._check_http_vulnerabilities,
            'ssl': self._check_ssl_vulnerabilities,
            'ports': self._check_port_vulnerabilities,
            'headers': self._check_header_vulnerabilities
        }
        
        # Configure HTTP session with retry logic
        self.session = self._create_session()
        warnings.filterwarnings('ignore', message='Unverified HTTPS request')

    def _create_session(self):
        """Create requests session with retry logic"""
        session = requests.Session()
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=[500, 502, 503, 504]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session

    def _is_port_open(self, host: str, port: int) -> bool:
        """Check if a port is open with proper error handling"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except socket.gaierror:
            self.logger.warning(f"Hostname {host} could not be resolved")
            return False
        except socket.error as e:
            self.logger.warning(f"Error checking port {port}: {str(e)}")
            return False

    def scan_target(self, target: str, checks: List[str] = None) -> Dict:
        """Perform vulnerability scan on target"""
        if not checks:
            checks = list(self.checks.keys())

        results = {
            'target': target,
            'scan_start': datetime.now().isoformat(),
            'vulnerabilities': [],
            'summary': {
                'high': 0,
                'medium': 0,
                'low': 0
            }
        }

        try:
            # Parse target
            parsed_target = urlparse(target)
            target_host = parsed_target.netloc or parsed_target.path
            target_host = target_host.split(':')[0]

            # Check basic connectivity first
            if not self._is_port_open(target_host, 80) and not self._is_port_open(target_host, 443):
                self.logger.warning(f"Target {target_host} appears to be unreachable")
                # Continue with scan anyway, as some ports might still be accessible

            # Run vulnerability checks
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = []
                
                for check in checks:
                    if check in self.checks:
                        check_func = self.checks[check]
                        futures.append(executor.submit(check_func, target_host))

                vulnerabilities = []
                for future in as_completed(futures):
                    try:
                        check_results = future.result()
                        if check_results:
                            vulnerabilities.extend(check_results)
                    except Exception as e:
                        self.logger.error(f"Check failed: {str(e)}")

            # Process vulnerabilities
            processed_vulns = self._process_vulnerabilities(vulnerabilities)
            results['vulnerabilities'] = processed_vulns
            
            # Update summary
            for vuln in processed_vulns:
                severity = vuln['severity'].lower()
                if severity in results['summary']:
                    results['summary'][severity] += 1

            results['scan_end'] = datetime.now().isoformat()
            return results

        except Exception as e:
            self.logger.error(f"Scan failed for {target}: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }

    def _check_http_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for common HTTP vulnerabilities"""
        vulnerabilities = []
        
        # Check HTTP connectivity
        http_accessible = False
        https_accessible = False
        
        try:
            # Try HTTP
            response = self.session.get(
                f"http://{target}", 
                timeout=10, 
                allow_redirects=False, 
                verify=False
            )
            http_accessible = True
            
            if response.status_code not in [301, 308]:
                vulnerabilities.append({
                    'type': 'http_redirect',
                    'name': 'Missing HTTP to HTTPS Redirect',
                    'description': 'Server does not redirect HTTP to HTTPS',
                    'severity': 'MEDIUM',
                    'evidence': f"HTTP Status Code: {response.status_code}"
                })
        except requests.RequestException as e:
            self.logger.warning(f"HTTP check failed: {str(e)}")

        try:
            # Try HTTPS
            response = self.session.get(
                f"https://{target}", 
                timeout=10, 
                verify=False
            )
            https_accessible = True
            
            # Check security headers
            headers = response.headers
            security_headers = {
                'Strict-Transport-Security': 'HSTS not enabled',
                'X-Content-Type-Options': 'Missing protection against MIME-type sniffing',
                'X-Frame-Options': 'Missing clickjacking protection'
            }

            for header, issue in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'missing_header',
                        'name': f'Missing {header}',
                        'description': issue,
                        'severity': 'MEDIUM',
                        'evidence': 'Header not present in response'
                    })
        except requests.RequestException as e:
            self.logger.warning(f"HTTPS check failed: {str(e)}")

        if not http_accessible and not https_accessible:
            vulnerabilities.append({
                'type': 'web_access',
                'name': 'Web Server Inaccessible',
                'description': 'Unable to access web server on standard ports (80/443)',
                'severity': 'HIGH',
                'evidence': 'Connection attempts failed'
            })

        return vulnerabilities

    def _check_ssl_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    version = ssock.version()
                    if version in ['TLSv1', 'TLSv1.1', 'SSLv2', 'SSLv3']:
                        vulnerabilities.append({
                            'type': 'weak_ssl',
                            'name': 'Weak SSL/TLS Version',
                            'description': f'Server supports outdated {version}',
                            'severity': 'HIGH',
                            'evidence': version
                        })

        except (socket.timeout, ssl.SSLError, ConnectionRefusedError) as e:
            self.logger.warning(f"SSL check failed: {str(e)}")
        except Exception as e:
            self.logger.warning(f"Unexpected SSL check error: {str(e)}")

        return vulnerabilities

    def _check_port_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for common port-related vulnerabilities"""
        vulnerabilities = []
        risky_ports = {
            21: 'FTP',
            23: 'Telnet',
            445: 'SMB',
            3389: 'RDP'
        }

        for port, service in risky_ports.items():
            if self._is_port_open(target, port):
                vulnerabilities.append({
                    'type': 'open_port',
                    'name': f'Potentially Risky Port Open: {port}',
                    'description': f'Port {port} ({service}) is open and could pose a security risk',
                    'severity': 'HIGH',
                    'evidence': f'Port {port} is accessible'
                })

        return vulnerabilities

    def _check_header_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for header-based vulnerabilities"""
        vulnerabilities = []
        try:
            response = self.session.get(
                f"https://{target}", 
                timeout=10, 
                verify=False
            )
            headers = response.headers

            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    vulnerabilities.append({
                        'type': 'info_disclosure',
                        'name': f'Information Disclosure in Headers',
                        'description': f'Header {header} reveals server information',
                        'severity': 'LOW',
                        'evidence': f'{header}: {headers[header]}'
                    })

        except requests.RequestException as e:
            self.logger.warning(f"Header check failed: {str(e)}")

        return vulnerabilities

    def _process_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Process and enhance vulnerability information"""
        processed = []
        for vuln in vulnerabilities:
            if vuln is None:
                continue
                
            vuln.setdefault('severity', 'low')
            vuln.setdefault('confidence', 'medium')
            vuln.setdefault('references', [])
            
            if 'cvss' not in vuln:
                vuln['cvss'] = self._calculate_cvss(vuln)
                
            processed.append(vuln)
            
        return sorted(processed, key=lambda x: x['severity'], reverse=True)

    def _calculate_cvss(self, vuln: Dict) -> float:
        """Calculate CVSS score based on vulnerability characteristics"""
        if vuln['severity'].lower() == 'high':
            return 7.5
        elif vuln['severity'].lower() == 'medium':
            return 5.0
        return 2.5