import re
from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

from vulnerability.correlation import VulnerabilityCorrelator


from .unified_scanner import UnifiedVulnerabilityScanner
from .models import Vulnerability
import json
import logging
from django.db.models import Count
from django.db import transaction

from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from .unified_scanner import UnifiedVulnerabilityScanner
import json
import logging

logger = logging.getLogger(__name__)  # Create logger at module level

# File to update: vulnerability/views.py

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = UnifiedVulnerabilityScanner()
        self.logger = logger  # Assign module logger to instance

    def post(self, request):
        try:
            data = json.loads(request.body)
            
            # Extract parameters with defaults
            target = data.get('target')
            scan_type = data.get('scan_type', 'standard')
            include_zap = data.get('include_zap', True)
            include_nuclei = data.get('include_nuclei', True)
            nuclei_scan_type = data.get('nuclei_scan_type', 'basic')
            # New parameter for advanced correlation
            use_advanced_correlation = data.get('use_advanced_correlation', True)

            # Validate required parameters
            if not target:
                return JsonResponse({
                    'status': 'error',
                    'error': 'Target is required'
                }, status=400)

            # Validate nuclei_scan_type
            if nuclei_scan_type not in ['basic', 'advanced']:
                return JsonResponse({
                    'status': 'error',
                    'error': 'nuclei_scan_type must be either "basic" or "advanced"'
                }, status=400)

            # Log scan configuration
            self.logger.info(f"Starting vulnerability scan for {target}")
            self.logger.info(
                f"Scan configuration - Type: {scan_type}, "
                f"ZAP: {include_zap}, "
                f"Nuclei: {include_nuclei} ({nuclei_scan_type}), "
                f"Advanced Correlation: {use_advanced_correlation}"
            )
            
            # Run the scan
            results = self.scanner.scan_target(
                target=target,
                scan_type=scan_type,
                include_zap=include_zap,
                include_nuclei=include_nuclei,
                nuclei_scan_type=nuclei_scan_type,
                use_advanced_correlation=use_advanced_correlation
            )
            
            # Deduplicate descriptions to reduce response size
            results = self._deduplicate_descriptions(results)
            
            return JsonResponse(results)

        except json.JSONDecodeError:
            self.logger.error("Invalid JSON in request body")
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            self.logger.exception(f"Error during vulnerability scan: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
            
    # Add this method to the VulnerabilityScanView class
    def _deduplicate_descriptions(self, results):
        """Remove duplicate paragraphs from vulnerability descriptions"""
        # Check if vulnerabilities field exists
        if 'vulnerabilities' in results:
            for vuln in results['vulnerabilities']:
                if 'description' in vuln and vuln['description']:
                    vuln['description'] = self._deduplicate_text(vuln['description'])
        
        # Also check for findings field
        if 'findings' in results:
            for finding in results['findings']:
                if 'description' in finding and finding['description']:
                    finding['description'] = self._deduplicate_text(finding['description'])
        
        return results

    def _deduplicate_text(self, text):
        """Remove duplicate content from a text string with improved handling for ZAP outputs"""
        if not text or len(text) < 100:  # Only process longer texts
            return text
        
        # Handle ZAP-specific patterns
        if text.startswith('zap: ') and '\n\nzap: ' in text:
            # Split by ZAP marker
            parts = text.split('\n\nzap: ')
            # Prepend 'zap: ' to all but the first part (which already has it)
            parts[0] = parts[0].removeprefix('zap: ')
            
            # Keep only unique parts
            unique_parts = []
            seen = set()
            
            for part in parts:
                # Skip empty parts
                if not part.strip():
                    continue
                    
                # Normalize for comparison
                norm_part = re.sub(r'\s+', ' ', part).strip().lower()
                if norm_part and norm_part not in seen:
                    seen.add(norm_part)
                    unique_parts.append(part)
            
            # Rebuild the text
            if unique_parts:
                return 'zap: ' + '\n\nzap: '.join(unique_parts)
        
        # Default handling for other text    
        if '\n\n' in text:
            separator = '\n\n'
        else:
            separator = '\n'
                
        # Split into paragraphs or lines
        parts = text.split(separator)
        
        # No need to process if very few parts
        if len(parts) <= 2:
            return text
                
        # Keep only unique parts
        unique_parts = []
        seen = set()
        
        for part in parts:
            # Skip empty parts
            if not part.strip():
                continue
                    
            # Normalize for comparison (strip whitespace, lowercase, remove extra spaces)
            norm_part = re.sub(r'\s+', ' ', part).strip().lower()
            if norm_part and norm_part not in seen:
                seen.add(norm_part)
                unique_parts.append(part)
        
        # If we got duplicates, rebuild the text
        if len(unique_parts) < len(parts):
            return separator.join(unique_parts)
        
        # No duplicates found
        return text

class VulnerabilityListView(View):
    def get(self, request):
        try:
            # Get filter parameters
            target = request.GET.get('target')
            severity = request.GET.get('severity')
            vuln_type = request.GET.get('type')
            source = request.GET.get('source')
            include_fixed = request.GET.get('include_fixed', 'false').lower() == 'true'

            # Build query
            query = Vulnerability.objects.all()
            if target:
                query = query.filter(target=target)
            if severity:
                query = query.filter(severity=severity.upper())
            if vuln_type:
                query = query.filter(vuln_type=vuln_type)
            if source:
                query = query.filter(source=source)
            if not include_fixed:
                query = query.filter(is_fixed=False)

            # Get vulnerabilities with selected fields
            vulnerabilities = query.values(
                'id', 'target', 'name', 'description', 'severity',
                'vuln_type', 'evidence', 'source', 'confidence',
                'discovery_date', 'is_fixed', 'fix_date', 'cvss_score'
            ).order_by('-discovery_date')

            return JsonResponse({
                'status': 'success',
                'count': len(vulnerabilities),
                'vulnerabilities': list(vulnerabilities)
            })

        except Exception as e:
            logger.error(f"Error listing vulnerabilities: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityUpdateView(View):
    def post(self, request, vuln_id):
        try:
            vulnerability = Vulnerability.objects.get(id=vuln_id)
            data = json.loads(request.body)

            # Update fields
            if 'is_fixed' in data:
                vulnerability.is_fixed = data['is_fixed']
            if 'notes' in data:
                vulnerability.notes = data['notes']
            if 'severity' in data:
                vulnerability.severity = data['severity'].upper()

            vulnerability.save()

            return JsonResponse({
                'status': 'success',
                'vulnerability': {
                    'id': vulnerability.id,
                    'name': vulnerability.name,
                    'is_fixed': vulnerability.is_fixed,
                    'notes': vulnerability.notes,
                    'severity': vulnerability.severity
                }
            })

        except Vulnerability.DoesNotExist:
            return JsonResponse({
                'status': 'error',
                'error': 'Vulnerability not found'
            }, status=404)
        except Exception as e:
            logger.error(f"Error updating vulnerability: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

class ScannerStatusView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = UnifiedVulnerabilityScanner()

    def get(self, request):
        try:
            status = self.scanner.get_scanner_status()
            return JsonResponse({
                'status': 'success',
                'scanners': status
            })
        except Exception as e:
            logger.error(f"Error getting scanner status: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
            
# vulnerability/views.py (Add these views to your existing views.py)

from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from .nuclei_scanner import NucleiScanner
from .models import NucleiFinding
import json
import logging

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class NucleiScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = NucleiScanner()

    def post(self, request):
        try:
            data = json.loads(request.body)
            target = data.get('target')
            scan_type = data.get('scan_type', 'basic')  # Default to basic scan
            scan_options = data.get('options', {})

            if not target:
                return JsonResponse({
                    'status': 'error',
                    'error': 'Target is required'
                }, status=400)

            # Choose scan type
            if scan_type == 'basic':
                logger.info(f"Starting basic Nuclei scan for {target}")
                scan_results = self.scanner.run_basic_scan(target)
            elif scan_type == 'advanced':
                logger.info(f"Starting advanced Nuclei scan for {target}")
                scan_results = self.scanner.run_advanced_scan(target, scan_options)
            else:
                logger.info(f"Starting custom Nuclei scan for {target}")
                scan_results = self.scanner.scan_target(target, scan_options)
            
            if scan_results.get('status') == 'success':
                # Prepare response with summary and limited findings
                findings = scan_results.get('findings', [])
                # Limit findings in response to first 10
                limited_findings = findings[:10] if len(findings) > 10 else findings
                
                response_data = {
                    'status': 'success',
                    'message': f'Nuclei scan completed for {target}',
                    'scan_id': scan_results.get('scan_id'),
                    'findings_count': len(findings),
                    'findings': limited_findings,  # Limit to first 10 for response size
                    'summary': scan_results.get('summary'),
                    'note': "Response limited to 10 findings" if len(findings) > 10 else ""
                }
                
                # Save findings to database
                saved_findings = []
                for finding in findings:
                    try:
                        nuclei_finding = NucleiFinding.objects.create(
                            template_id=finding.get('template_id', ''),
                            name=finding.get('name', ''),
                            severity=finding.get('severity', 'unknown').upper(),
                            finding_type=finding.get('type', ''),
                            host=finding.get('host', ''),
                            matched_at=finding.get('matched', ''),
                            description=finding.get('description', ''),
                            tags=finding.get('tags', []),
                            references=finding.get('references', []),
                            cwe=finding.get('cwe', ''),
                            cvss_score=finding.get('cvss_score'),
                            scan_id=scan_results.get('scan_id', ''),
                            target=target
                        )
                        saved_findings.append({
                            'id': nuclei_finding.id,
                            'name': nuclei_finding.name,
                            'severity': nuclei_finding.severity
                        })
                    except Exception as e:
                        logger.error(f"Error saving finding: {str(e)}")
                
                return JsonResponse(response_data)
            else:
                return JsonResponse({
                    'status': 'error',
                    'error': scan_results.get('error', 'Unknown error during scan')
                }, status=500)

        except json.JSONDecodeError:
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            logger.error(f"Error during Nuclei scan: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
            
class NucleiTemplatesView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = NucleiScanner()

    def get(self, request):
        """Get information about available Nuclei templates"""
        try:
            template_info = self.scanner.get_template_info()
            return JsonResponse(template_info)
        except Exception as e:
            logger.error(f"Error getting template info: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

    def post(self, request):
        """Update Nuclei templates"""
        try:
            update_result = self.scanner.update_templates()
            return JsonResponse(update_result)
        except Exception as e:
            logger.error(f"Error updating templates: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

class NucleiFindingsView(View):
    def get(self, request):
        """Get Nuclei findings with optional filters"""
        try:
            target = request.GET.get('target')
            severity = request.GET.get('severity')
            template_id = request.GET.get('template_id')
            
            query = NucleiFinding.objects.all()
            if target:
                query = query.filter(target=target)
            if severity:
                query = query.filter(severity=severity.upper())
            if template_id:
                query = query.filter(template_id=template_id)
                
            findings = query.values(
                'id', 'template_id', 'name', 'severity',
                'finding_type', 'host', 'matched_at',
                'discovery_date', 'cvss_score'
            ).order_by('-discovery_date')
            
            return JsonResponse({
                'status': 'success',
                'count': len(findings),
                'findings': list(findings)
            })
            
        except Exception as e:
            logger.error(f"Error retrieving Nuclei findings: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
            
            
# Add to vulnerability/views.py

# Imports needed at the top of views.py
from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.db.models import Count
from django.db import transaction
import json
import logging

from .correlation import VulnerabilityCorrelator
from .models import Vulnerability

# Then the CorrelationView class as provided previously
@method_decorator(csrf_exempt, name='dispatch')
class CorrelationView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.correlator = VulnerabilityCorrelator()
        self.logger = logging.getLogger(__name__)

    def post(self, request):
        """Correlate vulnerabilities from different sources"""
        try:
            data = json.loads(request.body)
            
            # Extract parameters
            target = data.get('target')
            
            # Extract findings from different scanners if provided
            internal_results = data.get('internal_results', [])
            zap_results = data.get('zap_results', [])
            nuclei_results = data.get('nuclei_results', [])
            openvas_results = data.get('openvas_results', [])
            manual_results = data.get('manual_results', [])
            
            # Whether to save results to database
            save_to_db = data.get('save_to_db', True)
            
            # Whether to deduplicate existing entries for this target
            deduplicate = data.get('deduplicate', True)
            
            # Validate that at least one scanner has results
            if not any([internal_results, zap_results, nuclei_results, openvas_results, manual_results]):
                return JsonResponse({
                    'status': 'error',
                    'error': 'At least one scanner must provide results'
                }, status=400)

            # Run correlation
            self.logger.info(f"Starting vulnerability correlation for {target}")
            correlation_results = self.correlator.correlate_findings(
                internal_results=internal_results,
                zap_results=zap_results,
                nuclei_results=nuclei_results,
                openvas_results=openvas_results,
                manual_results=manual_results,
                target=target if save_to_db else None  # Only save if requested
            )
            
            # If requested, deduplicate existing entries for this target
            if deduplicate and target and save_to_db:
                self._deduplicate_vulnerabilities(target)
            
            return JsonResponse(correlation_results)

        except json.JSONDecodeError:
            self.logger.error("Invalid JSON in request body")
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            self.logger.exception(f"Error during correlation: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
            
    def get(self, request):
        """Get correlated vulnerabilities for a target with enhanced filtering"""
        try:
            target = request.GET.get('target')
            if not target:
                return JsonResponse({
                    'status': 'error',
                    'error': 'Target parameter is required'
                }, status=400)
                
            # Additional filter parameters
            severity = request.GET.get('severity')
            source = request.GET.get('source')
            show_fixed = request.GET.get('show_fixed', 'false').lower() == 'true'
            correlated_only = request.GET.get('correlated_only', 'false').lower() == 'true'
            deduplicate = request.GET.get('deduplicate', 'true').lower() == 'true'
            
            # Deduplicate vulnerabilities if requested
            if deduplicate:
                deduplication_result = self._deduplicate_vulnerabilities(target)
                
            # Build query
            query = Vulnerability.objects.filter(target=target)
            
            if severity:
                query = query.filter(severity=severity.upper())
                
            if source:
                # Filter for vulnerabilities that contain this source
                query = query.filter(source__icontains=source)
                
            if not show_fixed:
                query = query.filter(is_fixed=False)
                
            # Get all matching vulnerabilities
            vulnerabilities = list(query)
            
            # Post-process for correlated findings if requested
            if correlated_only:
                vulnerabilities = [v for v in vulnerabilities if ',' in v.source]
            
            # Generate correlation statistics
            correlated_count = sum(1 for v in vulnerabilities if ',' in v.source)
            
            # Count by source
            source_stats = {}
            for vuln in vulnerabilities:
                for source in vuln.source.split(','):
                    source_stats[source] = source_stats.get(source, 0) + 1
            
            # Count by severity
            severity_stats = {
                'CRITICAL': sum(1 for v in vulnerabilities if v.severity == 'CRITICAL'),
                'HIGH': sum(1 for v in vulnerabilities if v.severity == 'HIGH'),
                'MEDIUM': sum(1 for v in vulnerabilities if v.severity == 'MEDIUM'),
                'LOW': sum(1 for v in vulnerabilities if v.severity == 'LOW')
            }
            
            # Serialize vulnerabilities for response
            vuln_data = []
            for vuln in vulnerabilities:
                vuln_data.append({
                    'id': vuln.id,
                    'name': vuln.name,
                    'description': vuln.description,
                    'severity': vuln.severity,
                    'vuln_type': vuln.vuln_type,
                    'source': vuln.source,
                    'sources': vuln.source.split(','),  # Parsed as list for convenience
                    'confidence': vuln.confidence,
                    'discovery_date': vuln.discovery_date.isoformat(),
                    'is_fixed': vuln.is_fixed,
                    'cvss_score': vuln.cvss_score,
                    'is_correlated': ',' in vuln.source
                })
            
            return JsonResponse({
                'status': 'success',
                'target': target,
                'total_vulnerabilities': len(vulnerabilities),
                'correlated_vulnerabilities': correlated_count,
                'source_statistics': source_stats,
                'severity_statistics': severity_stats,
                'filters_applied': {
                    'severity': severity,
                    'source': source,
                    'show_fixed': show_fixed,
                    'correlated_only': correlated_only
                },
                'vulnerabilities': vuln_data
            })
            
        except Exception as e:
            self.logger.error(f"Error retrieving correlated vulnerabilities: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)
    
    def _deduplicate_vulnerabilities(self, target):
        """
        Deduplicate vulnerabilities for a target by merging duplicates
        Returns statistics about the deduplication
        """
        try:
            start_count = Vulnerability.objects.filter(target=target).count()
            self.logger.info(f"Starting deduplication for {target} with {start_count} vulnerabilities")
            
            # Process batch by batch to avoid memory issues with large datasets
            # Group by name, vuln_type and severity
            deduplication_count = 0
            
            with transaction.atomic():
                # Get all distinct vulnerability signatures
                vulnerability_groups = Vulnerability.objects.filter(
                    target=target
                ).values('name', 'vuln_type', 'severity').annotate(
                    count=Count('id')
                ).filter(count__gt=1)  # Only process groups with duplicates
                
                for group in vulnerability_groups:
                    # Get all vulnerabilities matching this signature
                    duplicates = Vulnerability.objects.filter(
                        target=target,
                        name=group['name'],
                        vuln_type=group['vuln_type'],
                        severity=group['severity']
                    ).order_by('discovery_date')
                    
                    # Skip if only one vulnerability (should never happen due to our filter above)
                    if duplicates.count() <= 1:
                        continue
                        
                    # Keep the first vulnerability (oldest) and merge sources from the rest
                    base_vuln = duplicates.first()
                    sources = set(base_vuln.source.split(','))
                    references = set(base_vuln.references)
                    all_metadata = base_vuln.metadata.copy() if base_vuln.metadata else {}
                    
                    # Track all merged IDs for logging
                    merged_ids = []
                    
                    # Process all but the first vulnerability
                    for dup in duplicates[1:]:
                        # Add sources
                        for source in dup.source.split(','):
                            sources.add(source)
                        
                        # Add references
                        for ref in dup.references:
                            references.add(ref)
                        
                        # Merge metadata
                        if dup.metadata:
                            for key, value in dup.metadata.items():
                                if key not in all_metadata:
                                    all_metadata[key] = value
                                elif key == 'merged_ids':
                                    # Combine merged_ids lists
                                    all_metadata[key] = list(set(all_metadata[key] + value))
                        
                        # Track this ID as merged
                        merged_ids.append(dup.id)
                        
                        # Delete the duplicate
                        dup.delete()
                        deduplication_count += 1
                    
                    # Update the base vulnerability with merged data
                    base_vuln.source = ','.join(sorted(sources))
                    base_vuln.references = list(references)
                    
                    # Add merged_ids to metadata
                    if 'merged_ids' not in all_metadata:
                        all_metadata['merged_ids'] = []
                    all_metadata['merged_ids'].extend(merged_ids)
                    all_metadata['merged_ids'] = list(set(all_metadata['merged_ids']))
                    
                    # Update metadata
                    base_vuln.metadata = all_metadata
                    
                    # Save changes
                    base_vuln.save()
            
            end_count = Vulnerability.objects.filter(target=target).count()
            reduction = start_count - end_count
            
            self.logger.info(f"Deduplication completed: {reduction} duplicates merged")
            
            return {
                'status': 'success',
                'target': target,
                'original_count': start_count,
                'final_count': end_count,
                'duplicates_merged': reduction
            }
            
        except Exception as e:
            self.logger.error(f"Error during deduplication: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }
            
# Add this to your vulnerability/views.py file

@method_decorator(csrf_exempt, name='dispatch')
class NucleiDiagnosticView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        try:
            from .nuclei_scanner import NucleiScanner
            self.scanner = NucleiScanner()
        except Exception as e:
            self.scanner = None
            self.error = str(e)

    def get(self, request):
        """Run diagnostics on the Nuclei scanner setup"""
        if not self.scanner:
            return JsonResponse({
                'status': 'error',
                'error': f"Could not initialize Nuclei scanner: {getattr(self, 'error', 'Unknown error')}"
            }, status=500)
            
        try:
            diagnostic_results = self.scanner.diagnose()
            return JsonResponse({
                'status': 'success',
                'diagnostic_results': diagnostic_results
            })
        except Exception as e:
            logger.error(f"Error running Nuclei diagnostics: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)