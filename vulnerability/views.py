

from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

from vulnerability.zap_manager import ZAPManager
from .scanner import VulnerabilityScanner
from .models import Vulnerability
from django.utils import timezone
import json
import logging

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = VulnerabilityScanner()

    def post(self, request):
        try:
            data = json.loads(request.body)
            target = data.get('target')
            scan_type = data.get('scan_type', 'standard')

            if not target:
                return JsonResponse({
                    'error': 'Target is required'
                }, status=400)

            logger.info(f"Starting vulnerability scan for {target}")

            # Run the scan
            results = self.scanner.scan_target(target)
            
            # Save vulnerabilities
            saved_vulns = []
            if results.get('vulnerabilities'):
                for vuln in results['vulnerabilities']:
                    vulnerability = Vulnerability.objects.create(
                        target=target,
                        name=vuln['name'],
                        description=vuln.get('description', ''),
                        severity=vuln['severity'],
                        vuln_type=vuln.get('type', 'unknown'),
                        evidence=vuln.get('evidence', ''),
                        source='internal',
                        confidence=vuln.get('confidence', 'medium'),
                        cvss_score=vuln.get('cvss_score')
                    )
                    saved_vulns.append(vulnerability.id)

            response_data = {
                'status': 'success',
                'target': target,
                'scan_type': scan_type,
                'scanners_used': ['internal'],
                'scan_summary': results['summary'],
                'vulnerability_ids': saved_vulns
            }
            
            return JsonResponse(response_data)

        except json.JSONDecodeError:
            return JsonResponse({
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            logger.exception(f"Error during vulnerability scan: {str(e)}")
            return JsonResponse({
                'error': 'Scan failed',
                'details': str(e)
            }, status=500)

class VulnerabilityListView(View):
    def get(self, request):
        """Get list of vulnerabilities with optional filtering"""
        try:
            target = request.GET.get('target')
            severity = request.GET.get('severity')
            vuln_type = request.GET.get('type')
            include_fixed = request.GET.get('include_fixed', 'false').lower() == 'true'

            query = Vulnerability.objects.all()
            if target:
                query = query.filter(target=target)
            if severity:
                query = query.filter(severity=severity)
            if vuln_type:
                query = query.filter(vuln_type=vuln_type)
            if not include_fixed:
                query = query.filter(is_fixed=False)

            vulnerabilities = query.values(
                'id', 'target', 'name', 'severity', 
                'vuln_type', 'discovery_date', 'is_fixed',
                'fix_date'
            ).order_by('-discovery_date')

            return JsonResponse({
                'status': 'success',
                'vulnerabilities': list(vulnerabilities)
            })

        except Exception as e:
            logger.error(f"Error listing vulnerabilities: {str(e)}")
            return JsonResponse({
                'error': 'Failed to retrieve vulnerabilities',
                'details': str(e)
            }, status=500)

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class ZAPStatusView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.zap_manager = ZAPManager()

    def get(self, request):
        """Get ZAP status"""
        try:
            status = self.zap_manager.get_status()
            return JsonResponse({
                'status': 'success',
                'zap_status': status
            })
        except Exception as e:
            logger.error(f"Error getting ZAP status: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class ZAPTestView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.zap_manager = ZAPManager()

    def post(self, request):
        """Test ZAP connection with a target"""
        try:
            data = json.loads(request.body)
            target_url = data.get('target_url')

            if not target_url:
                return JsonResponse({
                    'status': 'error',
                    'error': 'target_url is required'
                }, status=400)

            # Ensure ZAP is running
            if not self.zap_manager.ensure_zap_running():
                return JsonResponse({
                    'status': 'error',
                    'error': 'Failed to start ZAP'
                }, status=500)

            # Test connection
            result = self.zap_manager.test_connection(target_url)
            return JsonResponse(result)

        except json.JSONDecodeError:
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            logger.error(f"Error testing ZAP connection: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)