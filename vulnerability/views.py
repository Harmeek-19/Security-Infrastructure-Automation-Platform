from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from .unified_scanner import UnifiedVulnerabilityScanner
from .models import Vulnerability
import json
import logging

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = UnifiedVulnerabilityScanner()

    def post(self, request):
        try:
            data = json.loads(request.body)
            target = data.get('target')
            scan_type = data.get('scan_type', 'standard')
            include_zap = data.get('include_zap', True)

            if not target:
                return JsonResponse({
                    'status': 'error',
                    'error': 'Target is required'
                }, status=400)

            logger.info(f"Starting vulnerability scan for {target}")
            results = self.scanner.scan_target(target, scan_type, include_zap)
            
            return JsonResponse(results)

        except json.JSONDecodeError:
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except Exception as e:
            logger.exception(f"Error during vulnerability scan: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

class VulnerabilityListView(View):
    def get(self, request):
        try:
            # Get filter parameters
            target = request.GET.get('target')
            severity = request.GET.get('severity')
            vuln_type = request.GET.get('type')
            source = request.GET.get('source')
            include_fixed = request.GET.get('include_fixed', 'false').lower() == 'true'

            # Build query
            query = Vulnerability.objects.all()
            if target:
                query = query.filter(target=target)
            if severity:
                query = query.filter(severity=severity.upper())
            if vuln_type:
                query = query.filter(vuln_type=vuln_type)
            if source:
                query = query.filter(source=source)
            if not include_fixed:
                query = query.filter(is_fixed=False)

            # Get vulnerabilities with selected fields
            vulnerabilities = query.values(
                'id', 'target', 'name', 'description', 'severity',
                'vuln_type', 'evidence', 'source', 'confidence',
                'discovery_date', 'is_fixed', 'fix_date', 'cvss_score'
            ).order_by('-discovery_date')

            return JsonResponse({
                'status': 'success',
                'count': len(vulnerabilities),
                'vulnerabilities': list(vulnerabilities)
            })

        except Exception as e:
            logger.error(f"Error listing vulnerabilities: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityUpdateView(View):
    def post(self, request, vuln_id):
        try:
            vulnerability = Vulnerability.objects.get(id=vuln_id)
            data = json.loads(request.body)

            # Update fields
            if 'is_fixed' in data:
                vulnerability.is_fixed = data['is_fixed']
            if 'notes' in data:
                vulnerability.notes = data['notes']
            if 'severity' in data:
                vulnerability.severity = data['severity'].upper()

            vulnerability.save()

            return JsonResponse({
                'status': 'success',
                'vulnerability': {
                    'id': vulnerability.id,
                    'name': vulnerability.name,
                    'is_fixed': vulnerability.is_fixed,
                    'notes': vulnerability.notes,
                    'severity': vulnerability.severity
                }
            })

        except Vulnerability.DoesNotExist:
            return JsonResponse({
                'status': 'error',
                'error': 'Vulnerability not found'
            }, status=404)
        except Exception as e:
            logger.error(f"Error updating vulnerability: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

class ScannerStatusView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = UnifiedVulnerabilityScanner()

    def get(self, request):
        try:
            status = self.scanner.get_scanner_status()
            return JsonResponse({
                'status': 'success',
                'scanners': status
            })
        except Exception as e:
            logger.error(f"Error getting scanner status: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)