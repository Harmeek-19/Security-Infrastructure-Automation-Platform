import logging
from typing import Dict, List, Optional
from datetime import datetime
import requests
from zapv2 import ZAPv2  # Updated import
import json
import time

from security_automation import settings
import logging
from typing import Dict, List, Optional
from datetime import datetime
import requests
from zapv2 import ZAPv2
import json
import time
from django.conf import settings

import logging
from typing import Dict, List, Optional
from datetime import datetime
import requests
from zapv2 import ZAPv2
import json
import time
from django.conf import settings
import urllib3
import socket

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class ScannerIntegration:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scanner_configs = {
            'zap': {
                'host': getattr(settings, 'ZAP_HOST', 'localhost'),
                'port': getattr(settings, 'ZAP_PORT', 8080),
                'api_key': getattr(settings, 'ZAP_API_KEY', 'change_me_please'),
                'timeout': getattr(settings, 'ZAP_TIMEOUT', 300)
            }
        }
        self.zap = None
        self.initialize_scanners()

    def run_zap_scan(self, target_url: str) -> Dict:
        """Run OWASP ZAP scan on target"""
        try:
            if not self._verify_zap_connection():
                raise Exception("ZAP is not responding")

            # Format and validate target URL
            target_url = self._format_target_url(target_url)
            if not self._validate_target(target_url):
                raise Exception(f"Unable to access target: {target_url}")

            # Clear previous session
            self.zap.core.new_session()

            # Access URL first to ensure it's in ZAP's site tree
            self.logger.info(f"Accessing target URL: {target_url}")
            self.zap.core.access_url(target_url)
            time.sleep(5)  # Wait for URL to be accessed

            # Configure target
            self.logger.info(f"Setting target in scope: {target_url}")
            self.zap.context.new_context("scan_context")
            context_id = self.zap.context.context("scan_context")
            self.zap.context.include_in_context("scan_context", f".*{target_url}.*")
            
            # Spider scan
            self.logger.info(f"Starting ZAP spider scan on {target_url}")
            try:
                scan_opts = {
                    'maxChildren': '10',
                    'recurse': 'true',
                    'contextName': 'scan_context',
                    'subtreeOnly': 'true'
                }
                scan_id = self.zap.spider.scan_as_user(
                    contextid=context_id,
                    url=target_url,
                    maxchildren=None,
                    recurse=True,
                    subtreeonly=True
                )
                
                # Monitor spider progress
                progress = 0
                while progress < 100:
                    progress = int(self.zap.spider.status(scan_id))
                    self.logger.info(f"Spider progress: {progress}%")
                    if progress >= 100:
                        break
                    time.sleep(5)
                    
                # Wait for passive scanning to complete
                time.sleep(5)
                    
            except Exception as e:
                self.logger.error(f"Spider scan failed: {str(e)}")
                raise

            # Active Scan
            self.logger.info("Starting ZAP active scan")
            try:
                # Configure scan policy
                self.zap.ascan.enable_all_scanners()
                
                # Start scan
                ascan_id = self.zap.ascan.scan(
                    url=target_url,
                    recurse=True,
                    in_scope_only=True,
                    scan_policy_name=None,
                    method=None,
                    post_data=True
                )
                
                # Monitor active scan progress
                progress = 0
                while progress < 100:
                    progress = int(self.zap.ascan.status(ascan_id))
                    self.logger.info(f"Active scan progress: {progress}%")
                    if progress >= 100:
                        break
                    time.sleep(5)
                    
            except Exception as e:
                self.logger.error(f"Active scan failed: {str(e)}")
                raise

            # Get results
            self.logger.info("Collecting scan results")
            alerts = self.zap.core.alerts()
            
            return {
                'status': 'success',
                'scanner': 'zap',
                'alerts': alerts,
                'scan_id': ascan_id,
                'timestamp': datetime.now().isoformat()
            }

        except Exception as e:
            self.logger.error(f"ZAP scan failed: {str(e)}")
            return {
                'status': 'error',
                'scanner': 'zap',
                'error': str(e)
            }

    def _validate_target(self, url: str) -> bool:
        """Validate target is accessible"""
        try:
            response = requests.get(
                url, 
                timeout=10, 
                verify=False,
                allow_redirects=True
            )
            return response.status_code < 500
        except Exception as e:
            self.logger.error(f"Target validation failed: {str(e)}")
            return False

    def _format_target_url(self, url: str) -> str:
        """Ensure URL is properly formatted"""
        url = url.strip()
        if not url.startswith(('http://', 'https://')):
            # Try HTTPS first, fallback to HTTP
            try:
                response = requests.get(f"https://{url}", timeout=5, verify=False)
                return f"https://{url}"
            except:
                return f"http://{url}"
        return url

    # [Rest of your methods remain the same]


    def initialize_scanners(self):
        """Initialize connections to external scanners"""
        try:
            # Initialize ZAP with proper API key
            self.zap = ZAPv2(
                apikey=self.scanner_configs['zap']['api_key'],
                proxies=None  # Don't use proxy for API calls
            )
            
            # Test connection
            version = self.zap.core.version
            self.logger.info(f"Successfully connected to ZAP {version}")
            return True
        except Exception as e:
            self.logger.error(f"Error initializing scanners: {str(e)}")
            return False

    
            
    def _check_http_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for common HTTP vulnerabilities with SSL verification disabled"""
        vulnerabilities = []
        try:
            # Check for HTTP to HTTPS redirect with SSL verification disabled
            try:
                response = requests.get(
                    f"http://{target}", 
                    allow_redirects=False, 
                    timeout=5,
                    verify=False  # Disable SSL verification
                )
                if response.status_code not in [301, 308]:
                    vulnerabilities.append({
                        'type': 'http_redirect',
                        'name': 'Missing HTTP to HTTPS Redirect',
                        'description': 'Server does not redirect HTTP to HTTPS',
                        'severity': 'MEDIUM',
                        'evidence': f"HTTP Status Code: {response.status_code}"
                    })
            except requests.exceptions.RequestException as e:
                self.logger.warning(f"HTTP check failed: {str(e)}")

            # Check for security headers with SSL verification disabled
            try:
                response = requests.get(
                    f"https://{target}", 
                    timeout=5,
                    verify=False  # Disable SSL verification
                )
                headers = response.headers
                
                # Rest of your header checks...

            except requests.exceptions.RequestException as e:
                self.logger.warning(f"HTTPS check failed: {str(e)}")

        except Exception as e:
            self.logger.error(f"Error in HTTP vulnerability check: {str(e)}")

        return vulnerabilities


    def _verify_zap_connection(self) -> bool:
        """Verify ZAP connection is working"""
        try:
            if not hasattr(self, 'zap'):
                self.initialize_scanners()
            version = self.zap.core.version
            return True
        except Exception as e:
            self.logger.error(f"ZAP connection verification failed: {str(e)}")
            return False
            

    def _process_zap_vulnerability(self, alert: Dict) -> Dict:
        """Process ZAP alert into standard vulnerability format"""
        return {
            'source': 'zap',
            'name': alert.get('name', ''),
            'description': alert.get('description', ''),
            'severity': self._normalize_severity(alert.get('risk')),
            'confidence': alert.get('confidence', ''),
            'evidence': alert.get('evidence', ''),
            'solution': alert.get('solution', ''),
            'references': alert.get('references', ''),
            'cwe': alert.get('cweid', ''),
            'metadata': {
                'url': alert.get('url', ''),
                'parameter': alert.get('parameter', '')
            }
        }

    def _normalize_severity(self, severity: str) -> str:
        """Normalize severity ratings across different scanners"""
        severity = str(severity).lower()
        
        if severity in ['critical', 'high', '3', '4']:
            return 'HIGH'
        elif severity in ['medium', 'warning', '2']:
            return 'MEDIUM'
        elif severity in ['low', 'info', '1']:
            return 'LOW'
        else:
            return 'INFO'

    def get_scanner_status(self) -> Dict:
        """Get status of all configured scanners"""
        status = {}
        
        # Check ZAP
        try:
            zap_version = self.zap.core.version
            status['zap'] = {
                'status': 'available',
                'version': zap_version
            }
        except:
            status['zap'] = {
                'status': 'unavailable',
                'error': 'Could not connect to ZAP'
            }
            
        return status