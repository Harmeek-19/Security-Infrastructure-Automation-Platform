import docker
import logging
import time
from django.conf import settings
import requests
from typing import Dict
from zapv2 import ZAPv2

class ZAPManager:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.client = docker.from_env()
        self.container_name = 'security_platform_zap'
        self.api_key = getattr(settings, 'ZAP_API_KEY', 'change_me_please')
        self.zap_host = getattr(settings, 'ZAP_HOST', 'localhost')
        self.zap_port = getattr(settings, 'ZAP_PORT', 8080)
        self.zap_address = f"http://{self.zap_host}:{self.zap_port}"
        self.zap = None

    def ensure_zap_running(self) -> bool:
        """Ensure ZAP container is running, start if not"""
        try:
            container = self.client.containers.get(self.container_name)
            if container.status != 'running':
                container.start()
                time.sleep(10)  # Wait for ZAP to initialize
            
            return self._initialize_zap()
            
        except docker.errors.NotFound:
            self.logger.info("ZAP container not found, starting new one")
            return self._start_zap_container()
        except Exception as e:
            self.logger.error(f"Error ensuring ZAP is running: {str(e)}")
            return False

    def _start_zap_container(self) -> bool:
        """Start a new ZAP container"""
        try:
            self.client.containers.run(
                'ghcr.io/zaproxy/zaproxy:stable',
                command=f'zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true -config api.key={self.api_key}',
                ports={'8080/tcp': self.zap_port},
                name=self.container_name,
                detach=True
            )
            time.sleep(10)  # Wait for ZAP to initialize
            return self._initialize_zap()
        except Exception as e:
            self.logger.error(f"Error starting ZAP container: {str(e)}")
            return False

    def _initialize_zap(self) -> bool:
        """Initialize ZAP API connection"""
        try:
            self.zap = ZAPv2(
                apikey=self.api_key,
                proxies={'http': self.zap_address, 'https': self.zap_address}
            )
            _ = self.zap.core.version
            return True
        except Exception as e:
            self.logger.error(f"Error initializing ZAP: {str(e)}")
            return False

    def get_status(self) -> Dict:
        """Get ZAP status"""
        status = {
            'available': False,
            'version': None,
            'error': None
        }

        try:
            if not self.zap:
                self._initialize_zap()
            
            if self.zap:
                version = self.zap.core.version
                status.update({
                    'available': True,
                    'version': version
                })
        except Exception as e:
            status['error'] = str(e)

        return status

    def run_scan(self, target: str) -> Dict:
        """Run ZAP scan on target"""
        try:
            if not self.zap:
                if not self._initialize_zap():
                    raise Exception("Could not initialize ZAP")

            # Format target URL
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"

            # Clear previous session
            self.zap.core.new_session()

            # Configure target
            self.logger.info(f"Starting scan for {target}")
            self.zap.context.new_context("scan_context")
            context_id = self.zap.context.context("scan_context")
            self.zap.context.include_in_context("scan_context", f".*{target}.*")

            # Spider scan
            scan_id = self.zap.spider.scan(target)
            self._wait_for_completion(
                lambda: int(self.zap.spider.status(scan_id)),
                "Spider scan"
            )

            # Active scan
            ascan_id = self.zap.ascan.scan(target)
            self._wait_for_completion(
                lambda: int(self.zap.ascan.status(ascan_id)),
                "Active scan"
            )

            # Get results
            alerts = self.zap.core.alerts()
            
            return {
                'status': 'success',
                'alerts': alerts,
                'scan_id': ascan_id,
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
            }

        except Exception as e:
            self.logger.error(f"ZAP scan failed: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }

    def _wait_for_completion(self, status_check, operation_name, timeout=300):
        """Wait for an operation to complete"""
        start_time = time.time()
        while status_check() < 100:
            if time.time() - start_time > timeout:
                raise TimeoutError(f"{operation_name} timed out")
            self.logger.info(f"{operation_name} progress: {status_check()}%")
            time.sleep(5)