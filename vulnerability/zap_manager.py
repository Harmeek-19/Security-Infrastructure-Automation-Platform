import docker
import logging
import time
from django.conf import settings
import requests
from typing import Dict, List
from zapv2 import ZAPv2

class ZAPManager:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.client = docker.from_env()
        self.container_name = 'security_platform_zap'
        self.api_key = getattr(settings, 'ZAP_API_KEY', 'change_me_please')
        self.zap_host = getattr(settings, 'ZAP_HOST', 'localhost')
        self.zap_port = getattr(settings, 'ZAP_PORT', 8080)
        self.zap_address = f"http://{self.zap_host}:{self.zap_port}"
        self.zap = None

    def ensure_zap_running(self) -> bool:
        """Ensure ZAP container is running, start if not"""
        try:
            container = self.client.containers.get(self.container_name)
            if container.status != 'running':
                self.logger.info(f"ZAP container found but not running. Starting container {self.container_name}")
                container.start()
                time.sleep(10)  # Wait for ZAP to initialize
            else:
                self.logger.info(f"ZAP container is already running: {self.container_name}")
            
            return self._initialize_zap()
            
        except docker.errors.NotFound:
            self.logger.info("ZAP container not found, starting new one")
            return self._start_zap_container()
        except Exception as e:
            self.logger.error(f"Error ensuring ZAP is running: {str(e)}")
            return False

    def _start_zap_container(self) -> bool:
        """Start a new ZAP container"""
        try:
            self.logger.info(f"Starting new ZAP container with name: {self.container_name}")
            self.client.containers.run(
                'ghcr.io/zaproxy/zaproxy:stable',
                command=f'zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true -config api.key={self.api_key}',
                ports={'8080/tcp': self.zap_port},
                name=self.container_name,
                detach=True
            )
            # Increase wait time to ensure ZAP is fully initialized
            self.logger.info("Waiting for ZAP to initialize...")
            time.sleep(15)  
            return self._initialize_zap()
        except Exception as e:
            self.logger.error(f"Error starting ZAP container: {str(e)}")
            return False

    def _initialize_zap(self) -> bool:
        """Initialize ZAP API connection"""
        try:
            self.logger.info(f"Initializing ZAP API connection to {self.zap_address}")
            self.zap = ZAPv2(
                apikey=self.api_key,
                proxies={'http': self.zap_address, 'https': self.zap_address}
            )
            version = self.zap.core.version
            self.logger.info(f"Successfully connected to ZAP API, version: {version}")
            return True
        except Exception as e:
            self.logger.error(f"Error initializing ZAP: {str(e)}")
            return False

    def get_status(self) -> Dict:
        """Get ZAP status"""
        status = {
            'available': False,
            'version': None,
            'error': None
        }

        try:
            if not self.zap:
                self._initialize_zap()
            
            if self.zap:
                version = self.zap.core.version
                status.update({
                    'available': True,
                    'version': version
                })
                self.logger.info(f"ZAP status: available, version {version}")
            else:
                self.logger.warning("ZAP not initialized, reporting as unavailable")
        except Exception as e:
            self.logger.error(f"Error getting ZAP status: {str(e)}")
            status['error'] = str(e)

        return status

    def run_scan(self, target: str) -> Dict:
        """Run ZAP scan on target"""
        try:
            if not self.zap:
                self.logger.info("ZAP not initialized, attempting to initialize")
                if not self._initialize_zap():
                    raise Exception("Could not initialize ZAP")

            # Format target URL - try both HTTP and HTTPS
            original_target = target
            if not target.startswith(('http://', 'https://')):
                # Try both protocols, starting with HTTPS
                https_target = f"https://{target}"
                http_target = f"http://{target}"
                
                # Try HTTPS first
                target = https_target
                self.logger.info(f"Target doesn't specify protocol, trying {target} first")
            
            # Log the start of the scan
            self.logger.info(f"Starting scan for {target}")

            # Clear previous session
            self.logger.info("Creating new ZAP session")
            self.zap.core.new_session()
            time.sleep(2)

            # Create a new context
            context_name = "scan_context"
            try:
                self.zap.context.remove_context(context_name)
            except:
                pass
                
            self.logger.info("Configuring scan context")
            self.zap.context.new_context(context_name)
            
            # Make the context pattern more permissive to include all sub-paths
            hostname = target.split('://', 1)[1].split('/', 1)[0]  # Extract the hostname
            context_pattern = f".*{hostname}.*"
            self.zap.context.include_in_context(context_name, context_pattern)
            
            # Try to access the URL - first try the specified protocol
            access_success = False
            try:
                self.logger.info(f"Accessing target URL: {target}")
                self.zap.core.access_url(target)
                time.sleep(5)
                access_success = True
            except Exception as e:
                self.logger.warning(f"Error accessing {target}: {str(e)}")
                
                # If HTTPS failed and we haven't tried HTTP yet, try HTTP
                if target.startswith("https://") and not original_target.startswith(('http://', 'https://')):
                    http_target = f"http://{original_target}"
                    self.logger.info(f"HTTPS access failed, trying HTTP: {http_target}")
                    try:
                        self.zap.core.access_url(http_target)
                        time.sleep(5)
                        target = http_target  # Switch to HTTP if that works
                        access_success = True
                    except Exception as http_e:
                        self.logger.warning(f"Error accessing {http_target}: {str(http_e)}")
            
            # Run the Spider scan
            self.logger.info("Starting Spider scan")
            spider_success = False
            try:
                scan_id = self.zap.spider.scan(target)
                self.logger.info(f"Spider scan started with ID: {scan_id}")
                spider_complete = self._wait_for_spider_completion(scan_id)
                if spider_complete:
                    self.logger.info("Spider scan completed successfully")
                    spider_success = True
                else:
                    self.logger.warning("Spider scan did not complete successfully")
            except Exception as e:
                self.logger.error(f"Error during Spider scan: {str(e)}")
            
            # Wait a bit before proceeding
            time.sleep(3)
            
            # Get the URLs in the site tree
            site_urls = []
            try:
                site_urls = self._get_site_urls(hostname)
                self.logger.info(f"Found {len(site_urls)} URLs in site tree")
            except Exception as e:
                self.logger.error(f"Error getting site URLs: {str(e)}")
            
            # If no URLs found in site tree, try to add the target manually
            if not site_urls:
                self.logger.warning("No URLs found in site tree, making additional attempts")
                try:
                    # Try direct access using both HTTP and HTTPS
                    protocols = ["http://", "https://"]
                    for protocol in protocols:
                        try:
                            attempt_url = f"{protocol}{original_target}"
                            self.logger.info(f"Manually accessing: {attempt_url}")
                            self.zap.core.access_url(attempt_url)
                            time.sleep(3)
                        except:
                            continue
                    
                    # Check if that added any URLs
                    site_urls = self._get_site_urls(hostname)
                    self.logger.info(f"After manual access: {len(site_urls)} URLs in site tree")
                except Exception as e:
                    self.logger.error(f"Error in manual URL access: {str(e)}")
            
            # If still no URLs, perform one more access with recurse=true
            if not site_urls:
                self.logger.warning("Still no URLs, trying recursive access")
                try:
                    for protocol in ["http://", "https://"]:
                        try:
                            self.logger.info(f"Recursive spidering: {protocol}{original_target}")
                            spider_id = self.zap.spider.scan(f"{protocol}{original_target}", recurse=True)
                            time.sleep(10)  # Wait a bit longer for recursive spider
                            site_urls = self._get_site_urls(hostname)
                            if site_urls:
                                break
                        except:
                            continue
                except Exception as e:
                    self.logger.error(f"Error in recursive spider: {str(e)}")
            
            # Run Active Scan - try to run it regardless of previous steps
            self.logger.info("Starting Active scan")
            ascan_id = None
            active_scan_success = False
            
            # Multiple approaches to run the active scan
            try:
                # First try the standard scan method
                ascan_id = self.zap.ascan.scan(target)
                self.logger.info(f"Active scan started with ID: {ascan_id}")
                scan_complete = self._wait_for_ascan_completion(ascan_id)
                if scan_complete:
                    self.logger.info("Active scan completed successfully")
                    active_scan_success = True
                else:
                    self.logger.warning("Active scan did not complete successfully")
            except Exception as e:
                self.logger.error(f"Standard active scan failed: {str(e)}")
                
                # If that fails, try scanning with a specific URL if we have any
                if site_urls:
                    try:
                        self.logger.info("Trying alternate active scan method")
                        # Try to scan the first URL we found
                        alt_target = site_urls[0]
                        ascan_id = self.zap.ascan.scan(alt_target)
                        self.logger.info(f"Alternate active scan started with ID: {ascan_id}")
                        self._wait_for_ascan_completion(ascan_id)
                    except Exception as alt_e:
                        self.logger.error(f"Alternate active scan failed: {str(alt_e)}")
            
            # Get scan results
            self.logger.info("Collecting scan results regardless of scan status")
            alerts = []
            try:
                # Try to get alerts for the target
                alerts = self.zap.core.alerts(baseurl=target)
                self.logger.info(f"ZAP scanner found {len(alerts)} vulnerabilities")
                
                # If no alerts found and we tried both protocols, try getting all alerts
                if not alerts and not original_target.startswith(('http://', 'https://')):
                    # Try getting alerts for both HTTP and HTTPS versions
                    http_alerts = self.zap.core.alerts(baseurl=f"http://{original_target}")
                    https_alerts = self.zap.core.alerts(baseurl=f"https://{original_target}")
                    alerts = http_alerts + https_alerts
                    self.logger.info(f"Retrieved {len(alerts)} vulnerabilities from multiple protocols")
                    
                # If still no alerts, try getting all alerts (no filter)
                if not alerts:
                    all_alerts = self.zap.core.alerts()
                    # Filter to only those matching our hostname
                    alerts = [a for a in all_alerts if hostname in a.get('url', '')]
                    self.logger.info(f"Retrieved {len(alerts)} vulnerabilities by filtering all alerts")
            except Exception as e:
                self.logger.error(f"Error getting alerts: {str(e)}")
            
            return {
                'status': 'success',
                'alerts': alerts,
                'scan_details': {
                    'spider_success': spider_success,
                    'active_scan_success': active_scan_success,
                    'urls_found': len(site_urls),
                    'scan_id': ascan_id
                },
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
            }

        except Exception as e:
            self.logger.error(f"ZAP scan failed: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }

    def _get_site_urls(self, hostname: str) -> List[str]:
        """Get URLs for a specific hostname from the site tree"""
        try:
            all_urls = self.zap.core.urls()
            if all_urls:
                return [url for url in all_urls if hostname in url]
            return []
        except Exception as e:
            self.logger.error(f"Error getting URLs: {str(e)}")
            return []

    def _wait_for_spider_completion(self, scan_id, timeout=300):
        """Wait for spider scan completion"""
        try:
            return self._wait_for_completion(
                lambda: self.zap.spider.status(scan_id),
                "Spider scan",
                timeout
            )
        except Exception as e:
            self.logger.error(f"Error waiting for Spider completion: {str(e)}")
            return False
            
    def _wait_for_ascan_completion(self, scan_id, timeout=600):
        """Wait for active scan completion"""
        try:
            return self._wait_for_completion(
                lambda: self.zap.ascan.status(scan_id),
                "Active scan",
                timeout
            )
        except Exception as e:
            self.logger.error(f"Error waiting for Active scan completion: {str(e)}")
            return False

    def _wait_for_completion(self, status_check, operation_name, timeout=300):
        """Wait for an operation to complete"""
        start_time = time.time()
        while True:
            try:
                status = status_check()
                # Handle string and non-integer responses
                if isinstance(status, str):
                    if status.lower() == 'does_not_exist':
                        self.logger.error(f"{operation_name} ID not found")
                        return False
                    
                    try:
                        progress = int(status)
                    except ValueError:
                        self.logger.error(f"Invalid {operation_name} progress value: {status}")
                        return False
                else:
                    progress = int(status)
                    
                if progress >= 100:
                    self.logger.info(f"{operation_name} completed: 100%")
                    return True
                    
                if time.time() - start_time > timeout:
                    self.logger.warning(f"{operation_name} timed out after {timeout} seconds")
                    return False
                    
                self.logger.info(f"{operation_name} progress: {progress}%")
                time.sleep(5)
                
            except Exception as e:
                self.logger.error(f"Error checking {operation_name} status: {str(e)}")
                # Continue checking rather than raising exception
                if time.time() - start_time > timeout:
                    return False
                time.sleep(5)