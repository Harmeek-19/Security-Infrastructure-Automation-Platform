import nmap
from typing import Dict, List, Optional
import logging
from datetime import datetime
import socket
import requests
from urllib.parse import urlparse
import concurrent.futures
import threading
from django.conf import settings

class ServiceIdentifier:
    def __init__(self):
        self.scanner = nmap.PortScanner()
        self.logger = logging.getLogger(__name__)
        self.timeout = getattr(settings, 'SERVICE_SCAN_TIMEOUT', 180)  # 3 minutes default
        self._stop_event = threading.Event()

    def identify_services(self, target: str, scan_type: str = 'standard') -> Dict:
        """Comprehensive service identification with timeout handling"""
        try:
            # Parse target
            parsed_target = urlparse(target)
            target_host = parsed_target.netloc or parsed_target.path
            target_host = target_host.split(':')[0]

            scan_config = self._get_scan_config(scan_type)
            self.logger.info(f"Starting {scan_type} service scan for {target_host}")

            # Use ThreadPoolExecutor for timeout handling
            with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
                future = executor.submit(self._run_service_scan, target_host, scan_config)
                try:
                    result = future.result(timeout=self.timeout)
                    return result
                except concurrent.futures.TimeoutError:
                    self._stop_event.set()
                    return {
                        'status': 'error',
                        'error': 'Scan timeout',
                        'details': f'Service scan exceeded {self.timeout} seconds'
                    }

        except Exception as e:
            self.logger.error(f"Service scan failed for {target}: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'details': 'Service scan failed'
            }
            
    def _get_scan_config(self, scan_type: str) -> Dict:
        """Get scan configuration based on scan type"""
        configs = {
            'quick': {
                'ports': '21-23,25,80,443,3306,8080',
                'arguments': '-sV -sT -Pn -T4 --version-light'  # Fast scan
            },
            'standard': {
                'ports': '1-1000',
                'arguments': '-sV -sT -Pn -T4 --version-all'  # Standard scan
            },
            'full': {
                'ports': '1-65535',
                'arguments': '-sV -sT -Pn -T4 -A --version-all'  # Full scan
            },
            'stealth': {
                'ports': '1-1000',
                'arguments': '-sV -sS -Pn -T2 --version-all'  # Stealth scan
            }
        }
        return configs.get(scan_type, configs['standard'])

    def _run_service_scan(self, target: str, config: Dict) -> Dict:
        """Execute the actual service scan with interrupt handling"""
        try:
            # Initial port discovery
            self.logger.info(f"Starting port discovery for {target}")
            open_ports = self._discover_ports(target, config)
            
            if not open_ports:
                return {
                    'status': 'success',
                    'services': [],
                    'total_services': 0,
                    'scan_stats': {'open_ports': 0}
                }

            # Detailed service scanning
            self.logger.info(f"Starting service detection on {len(open_ports)} ports")
            scan_result = self.scanner.scan(
                target,
                ports=','.join(map(str, open_ports)),
                arguments=config['arguments']
            )

            # Debug logging
            self.logger.info(f"Raw scan result structure: {list(scan_result.keys())}")
            self.logger.info(f"Scan hosts: {self.scanner.all_hosts()}")
            if target in self.scanner.all_hosts():
                self.logger.info(f"Protocols for {target}: {self.scanner[target].all_protocols()}")
                for proto in self.scanner[target].all_protocols():
                    self.logger.info(f"Ports for {proto}: {list(self.scanner[target][proto].keys())}")

            if self._stop_event.is_set():
                return {
                    'status': 'error',
                    'error': 'Scan interrupted',
                    'details': 'Service scan was interrupted'
                }

            # Process scan results
            services = []
            for host in self.scanner.all_hosts():
                for proto in self.scanner[host].all_protocols():
                    for port in self.scanner[host][proto].keys():
                        service_info = self.scanner[host][proto][port]
                        if service_info['state'] == 'open':
                            service_detail = {
                                'port': port,
                                'protocol': proto,
                                'state': service_info['state'],
                                'service': {
                                    'name': service_info.get('name', 'unknown'),
                                    'product': service_info.get('product', ''),
                                    'version': service_info.get('version', ''),
                                    'extrainfo': service_info.get('extrainfo', ''),
                                    'cpe': service_info.get('cpe', [])
                                },
                                'category': self._categorize_service(service_info),
                                'risk_level': self._assess_risk_level(service_info)
                            }
                            services.append(service_detail)

            # Enhance service information
            enhanced_services = []
            for service in services:
                try:
                    enhanced_service = self._enhance_service_info(target, service.copy())
                    if enhanced_service:
                        enhanced_services.append(enhanced_service)
                    else:
                        enhanced_services.append(service)
                except Exception as e:
                    self.logger.error(f"Error enhancing service {service.get('port')}: {str(e)}")
                    enhanced_services.append(service)

            scan_time = scan_result.get('nmap', {}).get('scanstats', {}).get('elapsed', 'unknown')
            self.logger.info(f"Scan completed in {scan_time} seconds")
            
            # Log found services
            for service in enhanced_services:
                self.logger.info(f"Found service: Port {service['port']} - {service['service']['name']} ({service['category']})")

            return {
                'status': 'success',
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'services': enhanced_services,
                'total_services': len(enhanced_services),
                'scan_stats': {
                    'open_ports': len(open_ports),
                    'scan_time': scan_time
                }
            }

        except Exception as e:
            self.logger.error(f"Error in service scan: {str(e)}")
            return {
                'status': 'error',
                'error': str(e),
                'details': 'Error during service scan execution'
            }

    def _discover_ports(self, target: str, config: Dict) -> List[int]:
        """Initial port discovery with timeout"""
        open_ports = set()
        ports_to_scan = self._parse_ports(config['ports'])
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            future_to_port = {
                executor.submit(self._check_port, target, port): port 
                for port in ports_to_scan
            }
            
            for future in concurrent.futures.as_completed(future_to_port):
                if not self._stop_event.is_set():
                    try:
                        is_open = future.result()
                        if is_open:
                            open_ports.add(future_to_port[future])
                    except:
                        continue
                else:
                    break

        return list(sorted(open_ports))

    def _check_port(self, target: str, port: int) -> bool:
        """Check if a port is open"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                return result == 0
        except:
            return False

    def _parse_ports(self, ports_str: str) -> List[int]:
        """Parse ports string into list of port numbers"""
        ports = set()
        for part in ports_str.split(','):
            if '-' in part:
                start, end = map(int, part.split('-'))
                ports.update(range(start, end + 1))
            else:
                ports.add(int(part))
        return list(ports)

    def _enhance_service_info(self, target: str, service: Dict) -> Dict:
        """Enhance service information with additional checks"""
        try:
            if service['service']['name'] == 'http':
                self._enhance_web_service(target, service)
            elif service['service']['name'] in ['ssh', 'ftp', 'smtp']:
                self._enhance_common_service(target, service)
            return service
        except:
            return service

    def _enhance_web_service(self, target: str, service: Dict) -> None:
        """Enhance web service information"""
        try:
            port = service['port']
            url = f"http{'s' if port == 443 else ''}://{target}:{port}"
            response = requests.get(url, timeout=3, verify=False)
            
            service['service']['headers'] = dict(response.headers)
            service['service']['status_code'] = response.status_code
            service['service']['technologies'] = self._detect_technologies(response)
        except:
            pass

    def _enhance_common_service(self, target: str, service: Dict) -> None:
        """Enhance common service information with banner grabbing"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(2)
                sock.connect((target, service['port']))
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                service['service']['banner'] = banner
        except:
            pass

    def _detect_technologies(self, response) -> List[str]:
        """Detect web technologies from response headers"""
        technologies = []
        headers = response.headers
        
        tech_headers = {
            'X-Powered-By': None,
            'Server': None,
            'X-AspNet-Version': 'ASP.NET',
            'X-Runtime': 'Ruby'
        }
        
        for header, tech in tech_headers.items():
            if header in headers:
                technologies.append(tech or headers[header])
                
        return technologies

    def _process_scan_results(self, target: str) -> List[Dict]:
        """Process scan results and categorize services"""
        services = []
        
        if target not in self.scanner.all_hosts():
            return services

        for proto in self.scanner[target].all_protocols():
            ports = self.scanner[target][proto].keys()
            
            for port in ports:
                service_info = self.scanner[target][proto][port]
                service_detail = {
                    'port': port,
                    'protocol': proto,
                    'state': service_info['state'],
                    'service': {
                        'name': service_info.get('name', 'unknown'),
                        'product': service_info.get('product', ''),
                        'version': service_info.get('version', ''),
                        'extrainfo': service_info.get('extrainfo', ''),
                        'cpe': service_info.get('cpe', [])
                    },
                    'category': self._categorize_service(service_info),
                    'risk_level': self._assess_risk_level(service_info)
                }
                services.append(service_detail)
        
        return services

    def _categorize_service(self, service_info: Dict) -> str:
        """Categorize service based on name and product"""
        service_categories = {
            'web': ['http', 'https', 'nginx', 'apache'],
            'database': ['mysql', 'postgresql', 'mongodb'],
            'mail': ['smtp', 'pop3', 'imap'],
            'file_transfer': ['ftp', 'sftp'],
            'remote_access': ['ssh', 'telnet', 'rdp'],
            'dns': ['dns', 'domain']
        }

        service_name = service_info.get('name', '').lower()
        
        for category, services in service_categories.items():
            if any(s in service_name for s in services):
                return category
        return 'other'

    def _assess_risk_level(self, service_info: Dict) -> str:
        """Basic risk assessment of services"""
        high_risk = ['telnet', 'ftp']
        medium_risk = ['smtp', 'pop3']
        
        service_name = service_info.get('name', '').lower()
        
        if any(service in service_name for service in high_risk):
            return 'HIGH'
        elif any(service in service_name for service in medium_risk):
            return 'MEDIUM'
        return 'LOW'

    def _log_service_details(self, target: str, services: List[Dict]) -> None:
        """Log detailed information about identified services"""
        self.logger.info(f"Service identification completed for {target}")
        self.logger.info(f"Total services identified: {len(services)}")
        
        for service in services:
            log_message = (
                f"Port {service['port']}/{service['protocol']}: "
                f"{service['service']['name']} "
                f"({service['category']}, Risk: {service['risk_level']})"
            )
            if service['service']['version']:
                log_message += f" Version: {service['service']['version']}"
            
            self.logger.info(log_message)# automation/processor.py

import threading
import time
import logging
from django.conf import settings
from django.db import connection

from .workflow_orchestrator import WorkflowOrchestrator
from .scheduler import ScanScheduler

logger = logging.getLogger(__name__)

class AutomationProcessor:
    """
    Process automation workflows and scheduled tasks in the background.
    Implemented as a singleton to ensure only one instance is running.
    """
    _instance = None
    _lock = threading.Lock()
    
    @classmethod
    def get_instance(cls):
        """Get or create the singleton instance"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance
    
    def __init__(self):
        self.orchestrator = WorkflowOrchestrator()
        self.scheduler = ScanScheduler()
        self.stop_flag = threading.Event()
        self.processing_thread = None
        self.interval = getattr(settings, 'AUTOMATION_PROCESSING_INTERVAL', 60)  # seconds
    
    def start(self):
        """Start the background processing thread if not already running"""
        if self.processing_thread and self.processing_thread.is_alive():
            logger.warning("Automation processor already running")
            return False
            
        self.stop_flag.clear()
        self.processing_thread = threading.Thread(
            target=self._processing_loop,
            daemon=True
        )
        self.processing_thread.start()
        logger.info("Automation processor started")
        return True
    
    def stop(self):
        """Stop the background processing thread"""
        if not self.processing_thread or not self.processing_thread.is_alive():
            logger.warning("Automation processor not running")
            return False
            
        self.stop_flag.set()
        self.processing_thread.join(timeout=10)
        logger.info("Automation processor stopped")
        return True
    
    def is_running(self):
        """Check if the processor is running"""
        return self.processing_thread is not None and self.processing_thread.is_alive()
    
    def _processing_loop(self):
        """Main processing loop for automation tasks"""
        logger.info("Automation processing loop started")
        
        while not self.stop_flag.is_set():
            try:
                # Process scheduled tasks
                scheduled_count = self.scheduler.process_scheduled_tasks()
                if scheduled_count > 0:
                    logger.info(f"Processed {scheduled_count} scheduled tasks")
                
                # Start pending workflows
                started_count = self.orchestrator.check_pending_workflows()
                if started_count > 0:
                    logger.info(f"Started {started_count} pending workflows")
                
                # Process workflow queue
                processed_count = self.orchestrator.process_workflow_queue()
                if processed_count > 0:
                    logger.info(f"Processed {processed_count} workflow tasks")
                
            except Exception as e:
                logger.error(f"Error in automation processing: {str(e)}")
            finally:
                # Close database connections to prevent connection leaks
                connection.close()
            
            # Sleep until next interval
            self.stop_flag.wait(self.interval)
        
        logger.info("Automation processing loop stopped")
    
    @classmethod
    def run_once(cls):
        """
        Run a single cycle of the processor, useful for cron jobs or manual triggers
        """
        processor = cls()
        
        try:
            # Process scheduled tasks
            scheduled_count = processor.scheduler.process_scheduled_tasks()
            
            # Start pending workflows
            started_count = processor.orchestrator.check_pending_workflows()
            
            # Process workflow queue
            processed_count = processor.orchestrator.process_workflow_queue()
            
            return {
                'scheduled_tasks_processed': scheduled_count,
                'workflows_started': started_count,
                'tasks_processed': processed_count
            }
            
        except Exception as e:
            logger.error(f"Error in one-time automation processing: {str(e)}")
            return {
                'error': str(e)
            }
        finally:
            # Close database connections
            connection.close()from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.db.models import Count, Q
from django.utils import timezone
from .models import Service, Subdomain, PortScan
from .service_identifier import ServiceIdentifier
import json
import logging
from .subdomain_enumerator import SubdomainEnumerator
from .scanner import PortScanner, ScanType
logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class SubdomainScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.enumerator = SubdomainEnumerator()
        
    def get(self, request):
        try:
            target = request.GET.get('target')
            if not target:
                return JsonResponse({'error': 'Target parameter is required'}, status=400)
                
            subdomains = Subdomain.objects.filter(domain=target).values(
                'subdomain', 'ip_address', 'discovered_date', 'is_active'
            )
            
            return JsonResponse({
                'status': 'success',
                'target': target,
                'subdomains': list(subdomains)
            })
        except Exception as e:
            logger.error(f"Error retrieving subdomains: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def post(self, request):
        try:
            data = json.loads(request.body)
            domain = data.get('domain')
            
            if not domain:
                return JsonResponse({'error': 'Domain is required'}, status=400)
            
            # Perform actual subdomain enumeration
            discovered = self.enumerator.enumerate_subdomains(domain)
            
            # Save results to database
            saved_subdomains = []
            for subdomain_data in discovered:
                subdomain, created = Subdomain.objects.update_or_create(
                    domain=domain,
                    subdomain=subdomain_data['subdomain'],
                    defaults={
                        'ip_address': subdomain_data['ip_address'],
                        'is_active': True
                    }
                )
                saved_subdomains.append({
                    'id': subdomain.id,
                    'subdomain': subdomain.subdomain,
                    'ip_address': subdomain.ip_address,
                    'status': 'created' if created else 'updated'
                })
            
            return JsonResponse({
                'status': 'success',
                'message': 'Subdomain scan completed',
                'domain': domain,
                'total_subdomains': len(saved_subdomains),
                'subdomains': saved_subdomains
            })
        except Exception as e:
            logger.error(f"Subdomain scan error: {str(e)}")
            return JsonResponse({
                'error': str(e)
            }, status=500)

class SubdomainListView(View):
    def get(self, request):
        try:
            domain = request.GET.get('domain')
            query = Subdomain.objects.all()
            
            if domain:
                query = query.filter(domain=domain)
            
            subdomains = query.values('id', 'domain', 'subdomain', 
                                    'ip_address', 'discovered_date')
            
            return JsonResponse({
                'status': 'success',
                'subdomains': list(subdomains)
            })
        except Exception as e:
            logger.error(f"Error listing subdomains: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class SubdomainDetailView(View):
    def get(self, request, subdomain_id):
        try:
            subdomain = Subdomain.objects.get(id=subdomain_id)
            return JsonResponse({
                'status': 'success',
                'subdomain': {
                    'id': subdomain.id,
                    'domain': subdomain.domain,
                    'subdomain': subdomain.subdomain,
                    'ip_address': subdomain.ip_address,
                    'discovered_date': subdomain.discovered_date.isoformat(),
                    'is_active': subdomain.is_active
                }
            })
        except Subdomain.DoesNotExist:
            return JsonResponse({'error': 'Subdomain not found'}, status=404)
        except Exception as e:
            logger.error(f"Error retrieving subdomain details: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class PortScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanner = PortScanner()
        self.logger = logging.getLogger(__name__)

    def post(self, request):
        try:
            data = json.loads(request.body)
            target = data.get('target')
            scan_type = data.get('scan_type', 'quick')
            custom_ports = data.get('ports')

            if not target:
                return JsonResponse({'error': 'Target is required'}, status=400)

            if scan_type not in ScanType.__members__ and not custom_ports:
                return JsonResponse({
                    'error': f'Invalid scan type. Available types: {", ".join(ScanType.__members__.keys())}'
                }, status=400)

            # Start the scan
            self.logger.info(f"Starting {scan_type} port scan for {target}")
            scan_result = self.scanner.scan(target, scan_type)

            if scan_result['status'] == 'success':
                saved_ports = []
                
                # Process and save results
                for host in scan_result['results']:
                    for port_data in host['ports']:
                        scan = PortScan.objects.create(
                            host=target,
                            port=port_data['port'],
                            service=port_data['service'],
                            state=port_data['state'],
                            protocol='tcp',
                            scan_status='completed',
                            scan_type=scan_type,
                            banner=port_data.get('extrainfo', ''),
                            notes=f"Version: {port_data.get('version', 'unknown')}"
                        )
                        saved_ports.append({
                            'port': scan.port,
                            'state': scan.state,
                            'service': scan.service
                        })

                return JsonResponse({
                    'status': 'success',
                    'message': f'Port scan completed for {target}',
                    'target': target,
                    'scan_type': scan_type,
                    'total_ports': len(saved_ports),
                    'open_ports': len([p for p in saved_ports if p['state'] == 'open']),
                    'ports': saved_ports,
                    'scan_time': scan_result['scan_info']['scan_time']
                })
            else:
                return JsonResponse({
                    'status': 'error',
                    'error': scan_result.get('error', 'Unknown error during scan')
                }, status=500)

        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            self.logger.error(f"Port scan error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def get(self, request):
        """Get scan results for a target"""
        try:
            target = request.GET.get('target')
            if not target:
                return JsonResponse({'error': 'Target parameter is required'}, status=400)

            scans = PortScan.objects.filter(
                host=target, 
                scan_status='completed'
            ).values(
                'port', 'service', 'state', 'protocol', 
                'banner', 'scan_date'
            ).order_by('port')

            return JsonResponse({
                'status': 'success',
                'target': target,
                'total_ports': len(scans),
                'open_ports': scans.filter(state='open').count(),
                'ports': list(scans)
            })

        except Exception as e:
            self.logger.error(f"Error retrieving port scan results: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

    def _estimate_scan_time(self, scan_type, ports):
        """Estimate scan time based on scan type and ports"""
        if scan_type == 'quick':
            return "1-2 minutes"
        elif scan_type == 'partial':
            return "5-10 minutes"
        elif scan_type == 'complete':
            return "30-60 minutes"
        elif scan_type == 'full':
            return "1-2 hours"
        else:
            # Custom port range
            port_count = len(ports.split(','))
            if port_count < 100:
                return "1-5 minutes"
            elif port_count < 1000:
                return "5-15 minutes"
            else:
                return "15+ minutes"

class PortScanListView(View):
    def get(self, request):
        try:
            host = request.GET.get('host')
            state = request.GET.get('state')
            
            query = PortScan.objects.all()
            if host:
                query = query.filter(host=host)
            if state:
                query = query.filter(state=state)
                
            scans = query.values('id', 'host', 'port', 'service', 
                               'state', 'protocol', 'scan_date')
            
            return JsonResponse({
                'status': 'success',
                'scans': list(scans)
            })
        except Exception as e:
            logger.error(f"Error listing port scans: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class PortScanDetailView(View):
    def get(self, request, scan_id):
        try:
            scan = PortScan.objects.get(id=scan_id)
            return JsonResponse({
                'status': 'success',
                'scan': {
                    'id': scan.id,
                    'host': scan.host,
                    'port': scan.port,
                    'service': scan.service,
                    'state': scan.state,
                    'protocol': scan.protocol,
                    'scan_date': scan.scan_date.isoformat(),
                    'banner': scan.banner,
                    'notes': scan.notes
                }
            })
        except PortScan.DoesNotExist:
            return JsonResponse({'error': 'Scan not found'}, status=404)
        except Exception as e:
            logger.error(f"Error retrieving scan details: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class ServiceScanView(View):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.identifier = ServiceIdentifier()
        self.logger = logging.getLogger(__name__)

    def post(self, request):
        try:
            data = json.loads(request.body)
            target = data.get('target')
            scan_type = data.get('scan_type', 'standard')

            if not target:
                return JsonResponse({'error': 'Target is required'}, status=400)

            # Start service identification
            self.logger.info(f"Starting {scan_type} service scan for {target}")
            results = self.identifier.identify_services(target, scan_type)

            if results['status'] == 'success':
                # Save discovered services
                saved_services = []
                for service_data in results['services']:
                    try:
                        service, created = Service.objects.update_or_create(
                            host=target,
                            port=service_data['port'],
                            protocol=service_data['protocol'],
                            defaults={
                                'name': service_data['service']['name'],
                                'product': service_data['service']['product'],
                                'version': service_data['service']['version'],
                                'extra_info': service_data['service'].get('extrainfo', ''),
                                'category': service_data['category'],
                                'risk_level': service_data['risk_level'],
                                'cpe': service_data['service'].get('cpe', [])
                            }
                        )
                        saved_services.append({
                            'id': service.id,
                            'port': service.port,
                            'name': service.name,
                            'version': service.version,
                            'risk_level': service.risk_level,
                            'status': 'created' if created else 'updated'
                        })
                    except Exception as e:
                        self.logger.error(f"Error saving service: {str(e)}")

                return JsonResponse({
                    'status': 'success',
                    'message': f"Service scan completed for {target}",
                    'target': target,
                    'total_services': len(saved_services),
                    'services': saved_services,
                    'scan_stats': results['scan_stats']
                })

            return JsonResponse({
                'status': 'error',
                'error': results.get('error', 'Unknown error'),
                'details': results.get('details', '')
            }, status=500)

        except Exception as e:
            self.logger.error(f"Service scan error: {str(e)}")
            return JsonResponse({
                'error': str(e)
            }, status=500)

    def get(self, request):
        try:
            target = request.GET.get('target')
            if not target:
                return JsonResponse({'error': 'Target parameter is required'}, status=400)
            
            # Get all services for target
            services = Service.objects.filter(host=target).values(
                'id', 'port', 'protocol', 'name', 'product',
                'version', 'category', 'risk_level', 'last_seen'
            )

            # Group by risk level
            risk_summary = {
                'HIGH': services.filter(risk_level='HIGH').count(),
                'MEDIUM': services.filter(risk_level='MEDIUM').count(),
                'LOW': services.filter(risk_level='LOW').count()
            }

            return JsonResponse({
                'status': 'success',
                'target': target,
                'services': list(services),
                'risk_summary': risk_summary,
                'total_services': len(services)
            })

        except Exception as e:
            self.logger.error(f"Error retrieving services: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class ServiceListView(View):
    def get(self, request):
        try:
            category = request.GET.get('category')
            risk_level = request.GET.get('risk_level')
            
            query = Service.objects.all()
            if category:
                query = query.filter(category=category)
            if risk_level:
                query = query.filter(risk_level=risk_level)
                
            services = query.values('id', 'host', 'port', 'name', 
                                  'category', 'risk_level', 'last_seen')
            
            return JsonResponse({
                'status': 'success',
                'services': list(services)
            })
        except Exception as e:
            logger.error(f"Error listing services: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class ServiceDetailView(View):
    def get(self, request, service_id):
        try:
            service = Service.objects.get(id=service_id)
            return JsonResponse({
                'status': 'success',
                'service': {
                    'id': service.id,
                    'host': service.host,
                    'port': service.port,
                    'protocol': service.protocol,
                    'name': service.name,
                    'product': service.product,
                    'version': service.version,
                    'category': service.category,
                    'risk_level': service.risk_level,
                    'extra_info': service.extra_info,
                    'cpe': service.cpe,
                    'last_seen': service.last_seen.isoformat()
                }
            })
        except Service.DoesNotExist:
            return JsonResponse({'error': 'Service not found'}, status=404)
        except Exception as e:
            logger.error(f"Error retrieving service details: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class ScanStatisticsView(View):
    def get(self, request):
        try:
            # Get time range from request
            days = int(request.GET.get('days', 7))
            time_threshold = timezone.now() - timezone.timedelta(days=days)
            
            # Collect statistics
            stats = {
                'total_subdomains': Subdomain.objects.count(),
                'active_subdomains': Subdomain.objects.filter(is_active=True).count(),
                'total_services': Service.objects.count(),
                'services_by_risk': {
                    level: Service.objects.filter(risk_level=level).count()
                    for level, _ in Service.RISK_LEVELS
                },
                'services_by_category': {
                    category: Service.objects.filter(category=category).count()
                    for category, _ in Service.CATEGORIES
                },
                'recent_scans': {
                    'port_scans': PortScan.objects.filter(
                        scan_date__gte=time_threshold).count(),
                    'service_scans': Service.objects.filter(
                        scan_date__gte=time_threshold).count(),
                }
            }
            
            return JsonResponse({
                'status': 'success',
                'statistics': stats
            })
        except Exception as e:
            logger.error(f"Error generating statistics: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)

class HostSummaryView(View):
    def get(self, request, host):
        try:
            # Collect host information
            summary = {
                'subdomains': list(Subdomain.objects.filter(
                    domain=host).values('subdomain', 'ip_address')),
                'services': list(Service.objects.filter(
                    host=host).values('port', 'name', 'risk_level')),
                'port_scans': list(PortScan.objects.filter(
                    host=host).values('port', 'state', 'service')),
                'risk_assessment': {
                    'high_risk_services': Service.objects.filter(
                        host=host, risk_level='HIGH').count(),
                    'open_ports': PortScan.objects.filter(
                        host=host, state='open').count(),
                }
            }
            
            return JsonResponse({
                'status': 'success',
                'host': host,
                'summary': summary
            })
            

        except Exception as e:
            logger.error(f"Error generating host summary: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)
        
class ResultsView(View):
    def get(self, request):
        """Get all scan results for a target"""
        try:
            target = request.GET.get('target')
            if not target:
                return JsonResponse({'error': 'Target parameter is required'}, status=400)

            # Get subdomain results
            subdomains = Subdomain.objects.filter(domain=target).values(
                'subdomain', 'ip_address', 'discovered_date', 'is_active'
            )

            # Get port scan results
            ports = PortScan.objects.filter(host=target).values(
                'port', 'service', 'state', 'protocol', 'banner'
            )

            # Get service results
            services = Service.objects.filter(host=target).values(
                'port', 'name', 'product', 'version', 'category', 'risk_level'
            )

            return JsonResponse({
                'status': 'success',
                'target': target,
                'results': {
                    'subdomains': list(subdomains),
                    'ports': list(ports),
                    'services': list(services),
                    'summary': {
                        'total_subdomains': len(subdomains),
                        'open_ports': ports.filter(state='open').count(),
                        'high_risk_services': services.filter(risk_level='HIGH').count()
                    }
                }
            })

        except Exception as e:
            logger.error(f"Error retrieving results: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)