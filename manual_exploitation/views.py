# manual_exploitation/views.py
from django.shortcuts import render, get_object_or_404, redirect
from django.views import View
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.utils import timezone
from django.db import transaction
from django.contrib import messages
import json
import logging
import subprocess
import os
import tempfile
import threading
import time
import traceback

from .models import (
    ExploitationSession, ExploitationLog, 
    ExploitationEvidence, SafetyControl, 
    ExploitationTemplate
)
from vulnerability.models import Vulnerability
from exploit_manager.models import Exploit
from exploit_manager.matcher import ExploitMatcher

logger = logging.getLogger(__name__)

class ExploitationDashboardView(View):
    """
    Dashboard for manual exploitation interface
    """
    def get(self, request):
        # Get basic statistics for the dashboard
        active_sessions = ExploitationSession.objects.filter(
            status__in=['in_progress', 'authorized']
        )
        completed_sessions = ExploitationSession.objects.filter(
            status='completed'
        )
        recent_sessions = ExploitationSession.objects.all().order_by('-created_at')[:10]
        
        # Get exploits with high match confidence
        from django.db.models import Max
        from exploit_manager.models import ExploitMatch
        
        top_matches = ExploitMatch.objects.values(
            'vulnerability__id', 'vulnerability__name', 'vulnerability__target'
        ).annotate(
            max_confidence=Max('confidence_score')
        ).filter(
            max_confidence__gte=0.7
        ).order_by('-max_confidence')[:10]
        
        context = {
            'active_sessions': active_sessions,
            'completed_sessions': completed_sessions,
            'recent_sessions': recent_sessions,
            'top_matches': top_matches,
            'total_sessions': ExploitationSession.objects.count(),
            'successful_exploits': ExploitationSession.objects.filter(success=True).count(),
            'failed_exploits': ExploitationSession.objects.filter(success=False).count()
        }
        
        return render(request, 'manual_exploitation/dashboard.html', context)


class ExploitationSessionListView(View):
    """
    List view for exploitation sessions
    """
    def get(self, request):
        status_filter = request.GET.get('status', None)
        target_filter = request.GET.get('target', None)
        
        sessions = ExploitationSession.objects.all()
        
        if status_filter:
            sessions = sessions.filter(status=status_filter)
        if target_filter:
            sessions = sessions.filter(target__icontains=target_filter)
            
        sessions = sessions.order_by('-created_at')
        
        return render(request, 'manual_exploitation/session_list.html', {
            'sessions': sessions,
            'status_filter': status_filter,
            'target_filter': target_filter
        })


@method_decorator(csrf_exempt, name='dispatch')
class ExploitationSessionCreateView(View):
    """
    Create a new exploitation session
    """
    def get(self, request):
        vulnerability_id = request.GET.get('vulnerability_id')
        exploit_id = request.GET.get('exploit_id')
        
        vulnerability = None
        exploit = None
        exploit_matches = []
        
        if vulnerability_id:
            vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
            # Get matching exploits
            from exploit_manager.models import ExploitMatch
            matches = ExploitMatch.objects.filter(
                vulnerability_id=vulnerability_id
            ).order_by('-confidence_score')
            
            exploit_matches = [{
                'id': match.exploit.id,
                'title': match.exploit.title,
                'confidence': match.confidence_score,
                'exploit_id': match.exploit.exploit_id
            } for match in matches]
            
        if exploit_id:
            exploit = get_object_or_404(Exploit, id=exploit_id)
        
        # Get safety controls
        safety_controls = SafetyControl.objects.filter(is_mandatory=True)
        
        # Get exploitation templates
        templates = ExploitationTemplate.objects.all()
        
        return render(request, 'manual_exploitation/session_create.html', {
            'vulnerability': vulnerability,
            'exploit': exploit,
            'exploit_matches': exploit_matches,
            'safety_controls': safety_controls,
            'templates': templates
        })
    
    def post(self, request):
        try:
            data = json.loads(request.body) if request.body else request.POST.dict()
            
            # Validate required fields
            required_fields = ['name', 'target', 'vulnerability_id', 'exploit_id']
            for field in required_fields:
                if field not in data:
                    return JsonResponse({
                        'status': 'error',
                        'message': f'Missing required field: {field}'
                    }, status=400)
            
            # Get vulnerability and exploit
            vulnerability = get_object_or_404(Vulnerability, id=data['vulnerability_id'])
            exploit = get_object_or_404(Exploit, id=data['exploit_id'])
            
            # Create session with transaction to ensure atomicity
            with transaction.atomic():
                session = ExploitationSession.objects.create(
                    name=data['name'],
                    target=data['target'],
                    description=data.get('description', ''),
                    vulnerability=vulnerability,
                    exploit=exploit,
                    parameters=data.get('parameters', {}),
                    customized_code=data.get('customized_code', exploit.code),
                    scope_limitations=data.get('scope_limitations', ''),
                    max_execution_time=data.get('max_execution_time', 300)
                )
                
                # Create initial log entry
                ExploitationLog.objects.create(
                    session=session,
                    level='info',
                    message=f"Session created for {session.target} using exploit: {exploit.title}"
                )
                
                # Log safety control status
                safety_checks = data.get('safety_checks', [])
                if safety_checks:
                    safety_message = "Safety controls applied: " + ", ".join(safety_checks)
                    ExploitationLog.objects.create(
                        session=session,
                        level='info',
                        message=safety_message
                    )
                    session.safety_checks_performed = True
                    session.save()
                
            if request.content_type == 'application/json':
                return JsonResponse({
                    'status': 'success',
                    'message': 'Exploitation session created successfully',
                    'session_id': session.id
                })
            else:
                messages.success(request, 'Exploitation session created successfully')
                return redirect('manual_exploitation:session_detail', session_id=session.id)
                
        except Exception as e:
            logger.error(f"Error creating exploitation session: {str(e)}")
            if request.content_type == 'application/json':
                return JsonResponse({
                    'status': 'error',
                    'message': str(e)
                }, status=500)
            else:
                messages.error(request, f'Error creating session: {str(e)}')
                return redirect('manual_exploitation:session_list')


class ExploitationSessionDetailView(View):
    """
    View exploitation session details
    """
    def get(self, request, session_id):
        session = get_object_or_404(ExploitationSession, id=session_id)
        
        # Get logs
        logs = session.logs.all().order_by('timestamp')
        
        # Get evidence
        evidence = session.evidence.all().order_by('-timestamp')
        
        return render(request, 'manual_exploitation/session_detail.html', {
            'session': session,
            'logs': logs,
            'evidence': evidence
        })


@method_decorator(csrf_exempt, name='dispatch')
class ExploitationExecuteView(View):
    """
    Execute an exploitation session
    """
    def post(self, request, session_id):
        session = get_object_or_404(ExploitationSession, id=session_id)
        
        # Check if session can be executed
        if session.status not in ['created', 'authorized']:
            return JsonResponse({
                'status': 'error',
                'message': f'Cannot execute session in {session.status} status'
            }, status=400)
        
        # Ensure safety checks are performed
        if not session.safety_checks_performed:
            return JsonResponse({
                'status': 'error',
                'message': 'Safety checks must be performed before execution'
            }, status=400)
        
        # Run execution in a separate thread
        execution_thread = threading.Thread(
            target=self._execute_session,
            args=(session,)
        )
        execution_thread.daemon = True
        execution_thread.start()
        
        # Update session status
        session.start_session()
        
        return JsonResponse({
            'status': 'success',
            'message': 'Exploitation session started'
        })
    
    def _execute_session(self, session):
        """Execute the exploitation in a controlled environment"""
        try:
            # Log start
            ExploitationLog.objects.create(
                session=session,
                level='info',
                message=f"Starting exploitation execution against {session.target}"
            )
            
            # Prepare execution environment
            with tempfile.TemporaryDirectory() as temp_dir:
                # Write exploit code to file
                exploit_file = os.path.join(temp_dir, 'exploit.py')
                with open(exploit_file, 'w') as f:
                    f.write(session.customized_code)
                
                # Prepare parameters
                params = []
                for key, value in session.parameters.items():
                    if key and value:
                        params.append(f"--{key}={value}")
                
                # Add target to parameters
                params.append(f"--target={session.target}")
                
                # Set a timeout for execution
                timeout = session.max_execution_time
                
                # Log command
                cmd = f"python {exploit_file} {' '.join(params)}"
                ExploitationLog.objects.create(
                    session=session,
                    level='info',
                    message=f"Executing command: {cmd}"
                )
                
                # Execute the exploit with timeout
                start_time = time.time()
                try:
                    process = subprocess.Popen(
                        ['python', exploit_file] + params,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        universal_newlines=True
                    )
                    
                    # Monitor the process with timeout
                    output, errors = "", ""
                    while process.poll() is None:
                        # Check if timeout exceeded
                        if time.time() - start_time > timeout:
                            process.kill()
                            ExploitationLog.objects.create(
                                session=session,
                                level='error',
                                message=f"Execution timed out after {timeout} seconds"
                            )
                            session.abort_session("Execution timed out")
                            return
                        
                        # Collect output in chunks
                        stdout_data = process.stdout.readline()
                        if stdout_data:
                            output += stdout_data
                            ExploitationLog.objects.create(
                                session=session,
                                level='info',
                                message=f"Output: {stdout_data.strip()}"
                            )
                            
                        stderr_data = process.stderr.readline()
                        if stderr_data:
                            errors += stderr_data
                            ExploitationLog.objects.create(
                                session=session,
                                level='warning',
                                message=f"Error: {stderr_data.strip()}"
                            )
                            
                        time.sleep(0.1)
                    
                    # Get any remaining output
                    stdout_data, stderr_data = process.communicate()
                    if stdout_data:
                        output += stdout_data
                        ExploitationLog.objects.create(
                            session=session,
                            level='info',
                            message=f"Output: {stdout_data.strip()}"
                        )
                    if stderr_data:
                        errors += stderr_data
                        ExploitationLog.objects.create(
                            session=session,
                            level='warning',
                            message=f"Error: {stderr_data.strip()}"
                        )
                    
                    # Save evidence
                    ExploitationEvidence.objects.create(
                        session=session,
                        name="Execution Output",
                        description="Standard output from exploit execution",
                        evidence_type="output",
                        content=output
                    )
                    
                    if errors:
                        ExploitationEvidence.objects.create(
                            session=session,
                            name="Execution Errors",
                            description="Standard error from exploit execution",
                            evidence_type="output",
                            content=errors
                        )
                    
                    # Check exit code
                    exit_code = process.returncode
                    success = exit_code == 0
                    
                    # Complete session
                    if success:
                        session.complete_session(
                            success=True,
                            summary=f"Exploitation completed successfully in {time.time() - start_time:.1f} seconds"
                        )
                        ExploitationLog.objects.create(
                            session=session,
                            level='success',
                            message="Exploitation completed successfully"
                        )
                    else:
                        session.complete_session(
                            success=False,
                            summary=f"Exploitation failed with exit code {exit_code}"
                        )
                        ExploitationLog.objects.create(
                            session=session,
                            level='error',
                            message=f"Exploitation failed with exit code {exit_code}"
                        )
                
                except Exception as e:
                    error_detail = traceback.format_exc()
                    ExploitationLog.objects.create(
                        session=session,
                        level='error',
                        message=f"Execution error: {str(e)}\n{error_detail}"
                    )
                    session.abort_session(f"Execution error: {str(e)}")
        
        except Exception as e:
            error_detail = traceback.format_exc()
            logger.error(f"Error in exploitation execution: {str(e)}\n{error_detail}")
            ExploitationLog.objects.create(
                session=session,
                level='critical',
                message=f"Critical error: {str(e)}\n{error_detail}"
            )
            session.abort_session(f"Critical error: {str(e)}")


@method_decorator(csrf_exempt, name='dispatch')
class ExploitationAbortView(View):
    """
    Abort an exploitation session
    """
    def post(self, request, session_id):
        session = get_object_or_404(ExploitationSession, id=session_id)
        
        # Check if session can be aborted
        if session.status not in ['in_progress', 'authorized']:
            return JsonResponse({
                'status': 'error',
                'message': f'Cannot abort session in {session.status} status'
            }, status=400)
        
        # Get abort reason
        data = json.loads(request.body) if request.content_type == 'application/json' else request.POST.dict()
        reason = data.get('reason', 'User requested abort')
        
        # Abort session
        session.abort_session(reason)
        
        # Log abort
        ExploitationLog.objects.create(
            session=session,
            level='warning',
            message=f"Session aborted: {reason}"
        )
        
        return JsonResponse({
            'status': 'success',
            'message': 'Exploitation session aborted'
        })


@method_decorator(csrf_exempt, name='dispatch')
class ExploitationAuthorizeView(View):
    """
    Authorize an exploitation session
    """
    def post(self, request, session_id):
        session = get_object_or_404(ExploitationSession, id=session_id)
        
        # Check if session can be authorized
        if session.status != 'created':
            return JsonResponse({
                'status': 'error',
                'message': f'Cannot authorize session in {session.status} status'
            }, status=400)
        
        # Get authorization details
        data = json.loads(request.body) if request.content_type == 'application/json' else request.POST.dict()
        authorizer = data.get('authorized_by', request.user.username if hasattr(request, 'user') else 'Anonymous')
        
        # Update session
        session.status = 'authorized'
        session.authorized_by = authorizer
        session.save()
        
        # Log authorization
        ExploitationLog.objects.create(
            session=session,
            level='info',
            message=f"Session authorized by {authorizer}"
        )
        
        return JsonResponse({
            'status': 'success',
            'message': 'Exploitation session authorized'
        })


@method_decorator(csrf_exempt, name='dispatch')
class ExploitationEvidenceView(View):
    """
    Add evidence to an exploitation session
    """
    def post(self, request, session_id):
        session = get_object_or_404(ExploitationSession, id=session_id)
        
        try:
            # Parse data based on content type
            if request.content_type == 'application/json':
                data = json.loads(request.body)
            else:
                data = request.POST.dict()
                
            # Create evidence
            evidence = ExploitationEvidence.objects.create(
                session=session,
                name=data.get('name', 'Untitled Evidence'),
                description=data.get('description', ''),
                evidence_type=data.get('evidence_type', 'other'),
                content=data.get('content', ''),
                metadata=data.get('metadata', {})
            )
            
            # Log evidence addition
            ExploitationLog.objects.create(
                session=session,
                level='info',
                message=f"Evidence added: {evidence.name}"
            )
            
            return JsonResponse({
                'status': 'success',
                'message': 'Evidence added successfully',
                'evidence_id': evidence.id
            })
            
        except Exception as e:
            logger.error(f"Error adding evidence: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)


class ExploitFinderView(View):
    """
    View to find exploits for vulnerabilities
    """
    def get(self, request):
        # Get filter parameters
        vulnerability_id = request.GET.get('vulnerability_id')
        target = request.GET.get('target')
        
        # Get vulnerabilities with matching exploits
        if vulnerability_id:
            vulnerabilities = Vulnerability.objects.filter(id=vulnerability_id)
        elif target:
            vulnerabilities = Vulnerability.objects.filter(target=target, is_fixed=False)
        else:
            # Get top 100 vulnerabilities by severity
            vulnerabilities = Vulnerability.objects.filter(
                is_fixed=False
            ).order_by(
                'severity'
            )[:100]
        
        from exploit_manager.models import ExploitMatch
        
        # Get exploit matches for these vulnerabilities
        vulnerability_ids = vulnerabilities.values_list('id', flat=True)
        matches = ExploitMatch.objects.filter(
            vulnerability_id__in=vulnerability_ids
        ).select_related(
            'vulnerability', 'exploit'
        ).order_by('-confidence_score')
        
        # Group matches by vulnerability
        grouped_matches = {}
        for match in matches:
            vuln_id = match.vulnerability.id
            if vuln_id not in grouped_matches:
                grouped_matches[vuln_id] = {
                    'vulnerability': match.vulnerability,
                    'matches': []
                }
            grouped_matches[vuln_id]['matches'].append(match)
        
        return render(request, 'manual_exploitation/exploit_finder.html', {
            'vulnerabilities': vulnerabilities,
            'grouped_matches': grouped_matches,
            'target_filter': target
        })


class ExploitTemplateView(View):
    """
    View to manage exploitation templates
    """
    def get(self, request, template_id=None):
        if template_id:
            # Get specific template
            template = get_object_or_404(ExploitationTemplate, id=template_id)
            return render(request, 'manual_exploitation/template_detail.html', {
                'template': template
            })
        else:
            # List all templates
            templates = ExploitationTemplate.objects.all()
            return render(request, 'manual_exploitation/template_list.html', {
                'templates': templates
            })
    
    @method_decorator(csrf_exempt)
    def post(self, request, template_id=None):
        try:
            # Parse data
            data = json.loads(request.body) if request.content_type == 'application/json' else request.POST.dict()
            
            if template_id:
                # Update existing template
                template = get_object_or_404(ExploitationTemplate, id=template_id)
                template.name = data.get('name', template.name)
                template.description = data.get('description', template.description)
                template.exploit_type = data.get('exploit_type', template.exploit_type)
                template.template_code = data.get('template_code', template.template_code)
                template.parameters = data.get('parameters', template.parameters)
                template.save()
                
                if request.content_type == 'application/json':
                    return JsonResponse({
                        'status': 'success',
                        'message': 'Template updated successfully'
                    })
                else:
                    messages.success(request, 'Template updated successfully')
                    return redirect('manual_exploitation:template_detail', template_id=template.id)
            else:
                # Create new template
                template = ExploitationTemplate.objects.create(
                    name=data.get('name', 'Untitled Template'),
                    description=data.get('description', ''),
                    exploit_type=data.get('exploit_type', 'custom'),
                    template_code=data.get('template_code', ''),
                    parameters=data.get('parameters', {})
                )
                
                # Add safety controls if specified
                safety_control_ids = data.get('safety_controls', [])
                if safety_control_ids:
                    template.required_safety_controls.set(safety_control_ids)
                
                if request.content_type == 'application/json':
                    return JsonResponse({
                        'status': 'success',
                        'message': 'Template created successfully',
                        'template_id': template.id
                    })
                else:
                    messages.success(request, 'Template created successfully')
                    return redirect('manual_exploitation:template_detail', template_id=template.id)
        
        except Exception as e:
            logger