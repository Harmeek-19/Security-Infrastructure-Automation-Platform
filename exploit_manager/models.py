# File: exploit_manager/models.py
from django.db import models

class ExploitSource(models.Model):
    """Represents an exploit data source like ExploitDB"""
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    api_url = models.URLField(blank=True)
    last_update = models.DateTimeField(null=True, blank=True)
    is_active = models.BooleanField(default=True)
    
    def __str__(self):
        return self.name

class Exploit(models.Model):
    """Represents an individual exploit"""
    # Core fields
    exploit_id = models.CharField(max_length=50)  # Original ID from source
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    
    # Classification
    type = models.CharField(max_length=100, blank=True)  # webapps, remote, local, etc.
    platform = models.CharField(max_length=100, blank=True)  # Windows, Linux, etc.
    
    # Vulnerability information
    vulnerability_name = models.CharField(max_length=255, blank=True)
    cve_id = models.CharField(max_length=50, blank=True)
    
    # Dates
    date_published = models.DateField(null=True, blank=True)
    date_added = models.DateTimeField(auto_now_add=True)
    date_updated = models.DateTimeField(auto_now=True)
    
    # Source information
    source = models.ForeignKey(ExploitSource, on_delete=models.CASCADE, related_name='exploits')
    source_url = models.URLField(blank=True)
    
    # Code and technical details
    code = models.TextField(blank=True)
    file_path = models.CharField(max_length=255, blank=True)  # If stored as file
    author = models.CharField(max_length=255, blank=True)
    
    # Additional metadata
    verified = models.BooleanField(default=False)
    score = models.FloatField(null=True, blank=True)  # Relevance or quality score
    metadata = models.JSONField(default=dict, blank=True)
    
    class Meta:
        unique_together = ('exploit_id', 'source')
        indexes = [
            models.Index(fields=['cve_id']),
            models.Index(fields=['exploit_id']),
            models.Index(fields=['type']),
        ]
    
    def __str__(self):
        return f"{self.title} ({self.exploit_id})"
    
class ExploitMatch(models.Model):
    """Represents a match between a vulnerability and an exploit"""
    STATUS_CHOICES = [
        ('pending', 'Pending Review'),
        ('confirmed', 'Confirmed Match'),
        ('rejected', 'Rejected Match'),
        ('exploited', 'Successfully Exploited')
    ]
    
    vulnerability = models.ForeignKey('vulnerability.Vulnerability', on_delete=models.CASCADE, related_name='exploit_matches')
    exploit = models.ForeignKey(Exploit, on_delete=models.CASCADE, related_name='vulnerability_matches')
    
    confidence_score = models.FloatField(default=0.5)  # 0.0 to 1.0
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # Match metadata
    match_reason = models.TextField(blank=True)
    matched_by = models.CharField(max_length=50, blank=True)  # user or system
    match_date = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)
    
    # User feedback
    notes = models.TextField(blank=True)
    
    class Meta:
        unique_together = ('vulnerability', 'exploit')
        indexes = [
            models.Index(fields=['status']),
            models.Index(fields=['confidence_score']),
        ]
    
    def __str__(self):
        return f"Match: {self.vulnerability.name} â†” {self.exploit.title}"