# exploit_manager/matcher.py
import logging
import re
from typing import List, Tuple, Dict, Optional

from django.db.models import Q
from django.utils import timezone

from vulnerability.models import Vulnerability
from .models import Exploit, ExploitMatch

class ExploitMatcher:
    """
    Matches vulnerabilities with potential exploits from the database
    using a generalized approach that works with any vulnerability type
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def match_vulnerability(self, vulnerability: Vulnerability) -> List[ExploitMatch]:
        """
        Find potential exploits for a vulnerability using a flexible matching approach
        
        Args:
            vulnerability: The vulnerability to match
            
        Returns:
            List of ExploitMatch objects
        """
        try:
            self.logger.info(f"Matching vulnerability: {vulnerability.name} [{vulnerability.severity}]")
            
            # First attempt classification-based matching
            matches = self._classify_and_match(vulnerability)
            
            # If no matches found, fall back to generic content-based matching
            if not matches:
                self.logger.info(f"No matches found via classification, trying generic matching")
                matches = self._generic_match(vulnerability)
            
            # If still no matches, try a last-resort approach
            if not matches:
                self.logger.info(f"No matches found via generic matching, using fallback method")
                matches = self._fallback_match(vulnerability)
            
            # Save matches to database
            saved_matches = self.save_matches(vulnerability, matches)
            
            self.logger.info(f"Found {len(saved_matches)} potential exploits for vulnerability ID {vulnerability.id}")
            return saved_matches
            
        except Exception as e:
            self.logger.error(f"Error matching vulnerability: {str(e)}")
            return []
    
    def _classify_and_match(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """
        Classify vulnerability type and apply appropriate matching strategy
        """
        vuln_name = vulnerability.name.lower()
        vuln_type = vulnerability.vuln_type.lower() if vulnerability.vuln_type else ""
        vuln_desc = vulnerability.description.lower()
        
        # Match aggregation
        matches = []
        
        # Category 1: Port-related vulnerabilities
        if ('port' in vuln_name or 'port' in vuln_type) or re.search(r'port\s+\d+', vuln_name):
            port_matches = self._match_port_vulnerabilities(vulnerability)
            matches.extend(port_matches)
        
        # Category 2: Header-related vulnerabilities
        header_terms = ['header', 'csp', 'hsts', 'clickjacking', 'content-type', 'frame-options',
                        'x-frame', 'x-content', 'strict-transport', 'csrf', 'security policy']
        if any(term in vuln_name or term in vuln_desc for term in header_terms):
            header_matches = self._match_header_vulnerabilities(vulnerability)
            matches.extend(header_matches)
        
        # Category 3: Web-related vulnerabilities
        web_terms = ['web', 'http', 'https', 'webapp', 'website', 'javascript', 'dom', 'nginx', 'apache', 
                    'iis', 'cdn', 'waf', 'wappalyzer', 'redirect', 'aspnet']
        if any(term in vuln_name or term in vuln_desc or term in vuln_type for term in web_terms):
            web_matches = self._match_web_vulnerabilities(vulnerability)
            matches.extend(web_matches)
        
        # Category 4: Authentication and access-related vulnerabilities
        auth_terms = ['auth', 'access', 'login', 'password', 'credential', 'session', 'token', 'csrf', 'authentication']
        if any(term in vuln_name or term in vuln_desc for term in auth_terms):
            auth_matches = self._match_auth_vulnerabilities(vulnerability)
            matches.extend(auth_matches)
        
        # Category 5: Information disclosure vulnerabilities
        disclosure_terms = ['disclosure', 'leak', 'information', 'debug', 'error', 'version', 'sensitive']
        if any(term in vuln_name or term in vuln_desc for term in disclosure_terms):
            disclosure_matches = self._match_disclosure_vulnerabilities(vulnerability)
            matches.extend(disclosure_matches)
        
        # Category 6: XSS and other injection vulnerabilities
        injection_terms = ['xss', 'script', 'injection', 'cross site', 'cross-site', 'sql', 'command', 'xxe']
        if any(term in vuln_name or term in vuln_desc for term in injection_terms):
            injection_matches = self._match_injection_vulnerabilities(vulnerability)
            matches.extend(injection_matches)
        
        # Category 7: SSH-related vulnerabilities
        ssh_terms = ['ssh', 'secure shell', 'openssh']
        if any(term in vuln_name or term in vuln_desc or term in vuln_type for term in ssh_terms):
            ssh_matches = self._match_ssh_vulnerabilities(vulnerability)
            matches.extend(ssh_matches)
        
        return matches
    
    def _generic_match(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """
        Generic content-based matching using keywords from vulnerability name and description
        """
        # Extract key terms from vulnerability name and description
        vuln_name = vulnerability.name.lower() if vulnerability.name else ""
        vuln_desc = vulnerability.description.lower() if vulnerability.description else ""
        vuln_type = vulnerability.vuln_type.lower() if vulnerability.vuln_type else ""
        
        # Extract keywords from name and description
        name_keywords = self._extract_keywords(vuln_name)
        desc_keywords = self._extract_keywords(vuln_desc, max_words=5)
        type_keywords = self._extract_keywords(vuln_type, max_words=2)
        
        # Combine keywords, ensuring no duplicates
        all_keywords = list(set(name_keywords + desc_keywords + type_keywords))
        
        self.logger.info(f"Generic matching with keywords: {all_keywords}")
        
        if not all_keywords:
            return []
            
        # Build query using keywords
        query = Q()
        
        # Each keyword adds to the OR query
        for keyword in all_keywords:
            if len(keyword) > 3:  # Only use keywords with more than 3 chars
                query |= Q(title__icontains=keyword) | Q(description__icontains=keyword)
        
        # Filter by exploit type based on severity for better relevance
        if vulnerability.severity == 'CRITICAL' or vulnerability.severity == 'HIGH':
            # For high severity, prioritize remote exploits
            exploits = Exploit.objects.filter(query).filter(
                Q(type__icontains='remote') | Q(type__icontains='webapps')
            ).order_by('-date_published')[:20]
        else:
            # For medium/low severity, use broader criteria
            exploits = Exploit.objects.filter(query).order_by('-date_published')[:20]
        
        matches = []
        for exploit in exploits:
            # Calculate match score based on keyword presence
            score = self._calculate_keyword_match_score(exploit, all_keywords)
            matches.append((exploit, score, "Keyword match"))
        
        return matches
    
    def _fallback_match(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """
        Last-resort matching when other strategies fail to find matches
        """
        # For fallback, we'll use a very broad approach based on severity and type
        matches = []
        
        # Categorize by severity
        if vulnerability.severity in ['CRITICAL', 'HIGH']:
            # For high severity, prioritize exploits for critical vulnerabilities
            exploits = Exploit.objects.filter(
                Q(title__icontains='critical') | 
                Q(description__icontains='critical')
            ).order_by('-date_published')[:10]
            
            for exploit in exploits:
                matches.append((exploit, 0.3, f"Severity-based match ({vulnerability.severity})"))
                
        elif vulnerability.severity == 'MEDIUM':
            # For medium severity, look for common vulnerability types
            exploits = Exploit.objects.filter(
                Q(type__icontains='remote') | 
                Q(type__icontains='webapps')
            ).order_by('-date_published')[:10]
            
            for exploit in exploits:
                matches.append((exploit, 0.2, "General exploit match"))
                
        else:  # LOW or INFO severity
            # For low severity, just get some reasonable matches
            exploits = Exploit.objects.all().order_by('-date_published')[:5]
            
            for exploit in exploits:
                matches.append((exploit, 0.1, "General vulnerability match"))
        
        return matches
    
    def _match_port_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match port-related vulnerabilities"""
        matches = []
        vuln_name = vulnerability.name.lower()
        
        # Extract port number and service
        port_match = re.search(r'port\s+(\d+)\s*\(?(.*?)\)?', vuln_name, re.IGNORECASE)
        if port_match:
            port_number = port_match.group(1)
            service_name = port_match.group(2).strip() if port_match.group(2) else ""
            
            self.logger.info(f"Matching port vulnerability: Port {port_number} ({service_name})")
            
            # Special handling based on port/service combinations
            if port_number in ['80', '443', '8080', '8443'] or 'http' in service_name.lower() or 'web' in service_name.lower():
                # HTTP/Web ports
                http_query = (
                    Q(title__icontains='http') | 
                    Q(description__icontains='http') | 
                    Q(title__icontains='web') | 
                    Q(description__icontains='web') | 
                    Q(type__icontains='webapps') |
                    Q(platform__icontains='php')
                )
                
                exploits = Exploit.objects.filter(http_query).order_by('-date_published')[:20]
                
                for exploit in exploits:
                    score = 0.5 if exploit.type.lower() == 'webapps' else 0.4
                    matches.append((exploit, score, f"Web/HTTP exploit for port {port_number}"))
                
            elif port_number == '22' or 'ssh' in service_name.lower():
                # SSH port
                ssh_query = (
                    Q(title__icontains='ssh') | 
                    Q(description__icontains='ssh') | 
                    Q(title__icontains='remote') | 
                    Q(description__icontains='remote access')
                )
                
                exploits = Exploit.objects.filter(ssh_query).order_by('-date_published')[:15]
                
                for exploit in exploits:
                    matches.append((exploit, 0.4, f"SSH exploit for port {port_number}"))
                
            elif port_number == '21' or 'ftp' in service_name.lower():
                # FTP port
                ftp_query = (
                    Q(title__icontains='ftp') | 
                    Q(description__icontains='ftp') | 
                    Q(title__icontains='file transfer')
                )
                
                exploits = Exploit.objects.filter(ftp_query).order_by('-date_published')[:15]
                
                for exploit in exploits:
                    matches.append((exploit, 0.4, f"FTP exploit for port {port_number}"))
                
            else:
                # Other ports - generic approach
                general_query = Q(title__icontains='port') | Q(type__icontains='remote')
                
                # Try to include service name in query if available
                if service_name:
                    service_terms = service_name.lower().split()
                    for term in service_terms:
                        if len(term) > 3:
                            general_query |= Q(title__icontains=term) | Q(description__icontains=term)
                
                exploits = Exploit.objects.filter(general_query).order_by('-date_published')[:15]
                
                for exploit in exploits:
                    matches.append((exploit, 0.3, f"Service/port exploit for port {port_number}"))
                
        elif 'open port' in vuln_name:
            # Generic open port without specific port in title
            # Try to find port info in description
            desc = vulnerability.description.lower()
            port_in_desc = re.search(r'port\s+(\d+)', desc)
            
            if port_in_desc:
                port_number = port_in_desc.group(1)
                # Recursively call with the port number we found
                dummy_vuln = Vulnerability(
                    name=f"Port {port_number} (Extracted)",
                    description=vulnerability.description,
                    severity=vulnerability.severity,
                    vuln_type=vulnerability.vuln_type
                )
                return self._match_port_vulnerabilities(dummy_vuln)
            else:
                # No specific port found, use generic remote exploits
                exploits = Exploit.objects.filter(
                    Q(type__icontains='remote') |
                    Q(title__icontains='network')
                ).order_by('-date_published')[:15]
                
                for exploit in exploits:
                    matches.append((exploit, 0.3, "Generic port/network exploit"))
        
        return matches
    
    def _match_web_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match web-related vulnerabilities"""
        matches = []
        vuln_name = vulnerability.name.lower()
        vuln_desc = vulnerability.description.lower()
        
        # Map of web vulnerability types to search terms
        web_vuln_types = {
            'redirect': ['redirect', 'http to https', 'forwarding'],
            'webapp': ['web application', 'webapp', 'website', 'modern web'],
            'server': ['apache', 'nginx', 'iis', 'frontend', 'server'],
            'waf': ['waf', 'web application firewall', 'firewall detection'],
            'tech': ['wappalyzer', 'technology', 'detection', 'framework'],
            'cdn': ['cdn', 'content delivery', 'akamai']
        }
        
        # Determine web vulnerability type
        web_types = []
        for wtype, terms in web_vuln_types.items():
            if any(term in vuln_name or term in vuln_desc for term in terms):
                web_types.append(wtype)
        
        # If no specific type identified, use general web type
        if not web_types:
            web_types = ['webapp']
        
        self.logger.info(f"Web vulnerability types: {web_types}")
        
        # Build query based on identified types
        query = Q(type__icontains='webapps')
        
        for wtype in web_types:
            if wtype == 'redirect':
                query |= Q(title__icontains='redirect') | Q(description__icontains='http')
            elif wtype == 'server':
                for server in ['apache', 'nginx', 'iis']:
                    if server in vuln_name or server in vuln_desc:
                        query |= Q(title__icontains=server) | Q(description__icontains=server)
            elif wtype == 'waf':
                query |= Q(title__icontains='firewall') | Q(description__icontains='waf')
            elif wtype == 'tech':
                query |= Q(title__icontains='framework') | Q(description__icontains='technology')
            elif wtype == 'cdn':
                query |= Q(title__icontains='cdn') | Q(description__icontains='content delivery')
        
        # Get exploits matching the query
        exploits = Exploit.objects.filter(query).order_by('-date_published')[:20]
        
        for exploit in exploits:
            # Score based on type match
            if exploit.type.lower() == 'webapps':
                score = 0.4
            else:
                score = 0.3
                
            matches.append((exploit, score, "Web vulnerability match"))
        
        # If we didn't find enough matches, broaden the search
        if len(matches) < 5:
            general_web_query = Q(type__icontains='webapps') | Q(title__icontains='web')
            general_exploits = Exploit.objects.filter(general_web_query).order_by('-date_published')[:10]
            
            for exploit in general_exploits:
                if not any(exploit.id == match[0].id for match in matches):  # Avoid duplicates
                    matches.append((exploit, 0.3, "General web exploit"))
        
        return matches
    
    def _match_header_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match header-related vulnerabilities (HSTS, CSP, X-Frame-Options, etc.)"""
        matches = []
        vuln_name = vulnerability.name.lower()
        vuln_desc = vulnerability.description.lower()
        
        # Map header types to related search terms
        header_types = {
            'hsts': ['hsts', 'strict-transport-security', 'transport security'],
            'csp': ['csp', 'content security policy', 'content-security-policy'],
            'clickjacking': ['clickjacking', 'x-frame-options', 'frame-options', 'anti-clickjacking'],
            'content-type': ['content-type-options', 'x-content-type-options', 'mime', 'sniff'],
            'csrf': ['csrf', 'cross-site request forgery', 'anti-csrf'],
            'powered-by': ['x-powered-by', 'server leaks', 'information header'],
            'version': ['version information', 'server header', 'version detect']
        }
        
        # Determine header type(s)
        detected_types = []
        for htype, terms in header_types.items():
            if any(term in vuln_name or term in vuln_desc for term in terms):
                detected_types.append(htype)
        
        self.logger.info(f"Header vulnerability types: {detected_types}")
        
        # If we identified specific types, build a targeted query
        if detected_types:
            query = Q()
            
            for htype in detected_types:
                if htype == 'hsts':
                    query |= Q(title__icontains='transport') | Q(description__icontains='https')
                elif htype == 'csp':
                    query |= Q(title__icontains='security policy') | Q(description__icontains='csp')
                elif htype == 'clickjacking':
                    query |= Q(title__icontains='clickjacking') | Q(description__icontains='frame')
                elif htype == 'content-type':
                    query |= Q(title__icontains='mime') | Q(description__icontains='sniff')
                elif htype == 'csrf':
                    query |= Q(title__icontains='csrf') | Q(description__icontains='forgery')
                elif htype in ['powered-by', 'version']:
                    query |= Q(title__icontains='disclosure') | Q(description__icontains='information')
            
            # Get exploits for specific header types
            specific_exploits = Exploit.objects.filter(query & Q(type__icontains='webapps')).order_by('-date_published')[:15]
            
            for exploit in specific_exploits:
                matches.append((exploit, 0.4, f"Header security match: {', '.join(detected_types)}"))
        
        # Always add some generic web security exploits as these often address header issues
        general_query = (
            Q(title__icontains='web security') | 
            Q(description__icontains='header') |
            Q(title__icontains='misconfiguration') |
            Q(description__icontains='security headers')
        )
        
        general_exploits = Exploit.objects.filter(general_query).order_by('-date_published')[:10]
        
        for exploit in general_exploits:
            # Avoid duplicates
            if not any(exploit.id == match[0].id for match in matches):
                matches.append((exploit, 0.3, "Web security configuration exploit"))
        
        return matches
    
    def _match_auth_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match authentication and access control vulnerabilities"""
        matches = []
        
        # Build query for auth-related vulnerabilities
        auth_query = (
            Q(title__icontains='auth') | 
            Q(description__icontains='authentication') |
            Q(title__icontains='login') | 
            Q(description__icontains='access control') |
            Q(title__icontains='bypass') | 
            Q(description__icontains='credential')
        )
        
        # Get exploits
        auth_exploits = Exploit.objects.filter(auth_query).order_by('-date_published')[:15]
        
        for exploit in auth_exploits:
            matches.append((exploit, 0.4, "Authentication/access vulnerability match"))
        
        return matches
    
    def _match_disclosure_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match information disclosure vulnerabilities"""
        matches = []
        vuln_name = vulnerability.name.lower()
        
        # Build query for disclosure vulnerabilities
        disclosure_query = (
            Q(title__icontains='disclosure') | 
            Q(description__icontains='information leak') |
            Q(title__icontains='sensitive') | 
            Q(description__icontains='exposure')
        )
        
        # Refine if it's debug/error related
        if 'debug' in vuln_name or 'error' in vuln_name:
            disclosure_query &= (
                Q(title__icontains='debug') | 
                Q(description__icontains='error') |
                Q(title__icontains='exception') | 
                Q(description__icontains='message')
            )
        
        # Get exploits
        disclosure_exploits = Exploit.objects.filter(disclosure_query).order_by('-date_published')[:15]
        
        for exploit in disclosure_exploits:
            matches.append((exploit, 0.4, "Information disclosure vulnerability match"))
        
        return matches
    
    def _match_injection_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match XSS and other injection vulnerabilities"""
        matches = []
        vuln_name = vulnerability.name.lower()
        vuln_desc = vulnerability.description.lower()
        
        # Determine injection type
        injection_type = None
        if 'xss' in vuln_name or 'cross site scripting' in vuln_name or 'cross-site scripting' in vuln_name:
            injection_type = 'xss'
            
            # Check for XSS type
            if 'dom' in vuln_name or 'dom based' in vuln_name or 'dom' in vuln_desc:
                injection_type = 'dom-xss'
            elif 'stored' in vuln_name or 'persistent' in vuln_name:
                injection_type = 'stored-xss'
            elif 'reflected' in vuln_name:
                injection_type = 'reflected-xss'
                
        elif 'sql' in vuln_name or 'sql injection' in vuln_name:
            injection_type = 'sqli'
            
            # Check for SQL injection type
            if 'blind' in vuln_name or 'blind' in vuln_desc:
                injection_type = 'blind-sqli'
            elif 'time' in vuln_name or 'time based' in vuln_name:
                injection_type = 'time-sqli'
                
        elif 'command' in vuln_name and 'injection' in vuln_name:
            injection_type = 'cmdi'
        elif 'xxe' in vuln_name or 'xml' in vuln_name:
            injection_type = 'xxe'
        
        # Build query based on injection type
        query = Q()
        
        if injection_type in ['xss', 'dom-xss', 'stored-xss', 'reflected-xss']:
            query = (
                Q(title__icontains='xss') | 
                Q(description__icontains='cross site scripting') |
                Q(title__icontains='cross-site') | 
                Q(description__icontains='script injection')
            )
            
            # Refine for specific XSS types
            if injection_type == 'dom-xss':
                query &= Q(title__icontains='dom') | Q(description__icontains='dom')
            elif injection_type == 'stored-xss':
                query &= Q(title__icontains='stored') | Q(description__icontains='persistent')
            elif injection_type == 'reflected-xss':
                query &= Q(title__icontains='reflected') | Q(description__icontains='reflected')
                
        elif injection_type in ['sqli', 'blind-sqli', 'time-sqli']:
            query = (
                Q(title__icontains='sql') | 
                Q(description__icontains='sql injection') |
                Q(title__icontains='sqli')
            )
            
            # Refine for specific SQL injection types
            if injection_type == 'blind-sqli':
                query &= Q(title__icontains='blind') | Q(description__icontains='blind')
            elif injection_type == 'time-sqli':
                query &= Q(title__icontains='time') | Q(description__icontains='time based')
                
        elif injection_type == 'cmdi':
            query = (
                Q(title__icontains='command') | 
                Q(description__icontains='command injection') |
                Q(title__icontains='os command') | 
                Q(description__icontains='shell command')
            )
            
        elif injection_type == 'xxe':
            query = (
                Q(title__icontains='xxe') | 
                Q(description__icontains='xml external entity') |
                Q(title__icontains='xml injection')
            )
            
        else:
            # Generic injection query
            query = (
                Q(title__icontains='injection') | 
                Q(description__icontains='injection')
            )
        
        # Get matching exploits
        injection_exploits = Exploit.objects.filter(query).order_by('-date_published')[:15]
        
        for exploit in injection_exploits:
            if injection_type:
                match_reason = f"{injection_type.upper()} vulnerability match"
            else:
                match_reason = "Injection vulnerability match"
                
            matches.append((exploit, 0.5, match_reason))  # Higher score for injection vulnerabilities
        
        return matches
    
    def _match_ssh_vulnerabilities(self, vulnerability: Vulnerability) -> List[Tuple[Exploit, float, str]]:
        """Match SSH-related vulnerabilities"""
        matches = []
        vuln_name = vulnerability.name.lower()
        vuln_desc = vulnerability.description.lower()
        
        # Build query for SSH vulnerabilities
        ssh_query = (
            Q(title__icontains='ssh') | 
            Q(description__icontains='secure shell') |
            Q(title__icontains='openssh') | 
            Q(platform__icontains='ssh')
        )
        
        # Enhance query based on specifics
        if 'auth' in vuln_name or 'authentication' in vuln_name or 'auth' in vuln_desc:
            ssh_query &= (
                Q(title__icontains='auth') | 
                Q(description__icontains='authentication') |
                Q(title__icontains='login')
            )
            
            auth_exploits = Exploit.objects.filter(ssh_query).order_by('-date_published')[:15]
            
            for exploit in auth_exploits:
                matches.append((exploit, 0.5, "SSH authentication vulnerability match"))
        else:
            # General SSH exploits
            general_ssh_exploits = Exploit.objects.filter(ssh_query).order_by('-date_published')[:15]
            
            for exploit in general_ssh_exploits:
                matches.append((exploit, 0.4, "SSH service vulnerability match"))
        
        # If no SSH-specific exploits, try broader remote access exploits
        if not matches:
            remote_query = (
                Q(type__icontains='remote') & 
                (Q(title__icontains='authentication') | Q(description__icontains='login'))
            )
            
            remote_exploits = Exploit.objects.filter(remote_query).order_by('-date_published')[:10]
            
            for exploit in remote_exploits:
                matches.append((exploit, 0.3, "Remote access vulnerability match"))
        
        return matches
    
    def _extract_keywords(self, text: str, max_words: int = 6) -> List[str]:
        """Extract keywords from text, excluding common words"""
        if not text:
            return []
            
        # Common words to exclude
        common_words = {
            'the', 'a', 'an', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'be', 'been',
            'has', 'have', 'had', 'do', 'does', 'did', 'not', 'on', 'in', 'at', 'to', 'for',
            'with', 'by', 'about', 'against', 'between', 'into', 'through', 'during', 'before',
            'after', 'above', 'below', 'from', 'up', 'down', 'of', 'this', 'that', 'these', 
            'those', 'should', 'could', 'would', 'will', 'can', 'may', 'might', 'must', 'server',
            'vulnerability', 'issue', 'security', 'missing', 'detection', 'found', 'version'
        }
        
        # Split text into words, convert to lowercase, and filter
        words = re.findall(r'\b\w+\b', text.lower())
        # Split text into words, convert to lowercase, and filter
        words = re.findall(r'\b\w+\b', text.lower())
        keywords = [word for word in words if word not in common_words and len(word) > 2]
        
        # Limit number of keywords
        return keywords[:max_words]
    
    def _calculate_keyword_match_score(self, exploit: Exploit, keywords: List[str]) -> float:
        """Calculate match score based on keyword presence in exploit"""
        if not keywords:
            return 0.2  # Baseline score
            
        title = exploit.title.lower()
        description = exploit.description.lower() if exploit.description else ""
        
        # Count matches in title (weighted higher)
        title_matches = sum(1 for keyword in keywords if keyword in title)
        
        # Count matches in description
        desc_matches = sum(1 for keyword in keywords if keyword in description)
        
        # Calculate weighted score
        total_keywords = len(keywords)
        if total_keywords == 0:
            return 0.2
            
        score = (title_matches * 2 + desc_matches) / (total_keywords * 3)
        
        # Scale to appropriate range (0.2 - 0.8)
        return min(0.8, max(0.2, score * 0.8))
    
    def save_matches(self, vulnerability: Vulnerability, matches: List[Tuple[Exploit, float, str]]) -> List[ExploitMatch]:
        """Save matches to database and return saved objects"""
        saved_matches = []
        
        # Sort by confidence score (highest first)
        sorted_matches = sorted(matches, key=lambda x: x[1], reverse=True)
        
        # Limit number of matches to save
        max_matches = 10
        sorted_matches = sorted_matches[:max_matches]
        
        for exploit, confidence, reason in sorted_matches:
            try:
                # Skip exploits with very low confidence
                if confidence < 0.1:
                    continue
                    
                # Get or create match object
                match, created = ExploitMatch.objects.get_or_create(
                    vulnerability=vulnerability,
                    exploit=exploit,
                    defaults={
                        'confidence_score': confidence,
                        'match_reason': reason,
                        'status': 'pending',
                        # match_date is auto_now_add - no need to set it explicitly
                    }
                )
                
                # Update if it already existed
                if not created:
                    match.confidence_score = confidence
                    match.match_reason = reason
                    # last_updated has auto_now=True - no need to set it explicitly
                    match.save()
                
                saved_matches.append(match)
                
            except Exception as e:
                self.logger.error(f"Error saving match: {str(e)}")
        
        return saved_matches