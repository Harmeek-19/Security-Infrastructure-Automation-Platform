# File: exploit_manager/views.py
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponse, JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.core.paginator import Paginator
from django.db.models import Q
import json
import logging
from .models import Exploit, ExploitMatch
from .exploit_db import ExploitDBManager
from .matcher import ExploitMatcher
from vulnerability.models import Vulnerability

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
class ExploitSearchView(View):
    """
    View for searching exploits
    """
    def get(self, request):
        """Handle GET requests"""
        try:
            # Parse search parameters
            query = request.GET.get('query', '')
            cve = request.GET.get('cve', '')
            platform = request.GET.get('platform', '')
            exploit_type = request.GET.get('type', '')
            page = int(request.GET.get('page', 1))
            limit = min(int(request.GET.get('limit', 20)), 100)
            
            # Determine search source
            source = request.GET.get('source', 'db')
            
            if source == 'exploitdb':
                # Search ExploitDB directly
                exploitdb = ExploitDBManager()
                results = exploitdb.search_exploits(
                    query=query,
                    cve=cve,
                    platform=platform,
                    exploit_type=exploit_type,
                    limit=limit
                )
                
                return JsonResponse({
                    'status': 'success',
                    'count': len(results),
                    'results': results
                })
            else:
                # Search local database
                query_obj = Q()
                
                if query:
                    query_obj |= Q(title__icontains=query)
                    query_obj |= Q(description__icontains=query)
                
                if cve:
                    query_obj |= Q(cve_id__icontains=cve)
                
                if platform:
                    query_obj |= Q(platform__icontains=platform)
                    
                if exploit_type:
                    query_obj |= Q(type__icontains=exploit_type)
                
                # If no filters, ensure we have some constraints
                if not (query or cve or platform or exploit_type):
                    return JsonResponse({
                        'status': 'error',
                        'message': 'At least one search parameter is required'
                    }, status=400)
                
                # Execute query
                exploits = Exploit.objects.filter(query_obj).order_by('-date_published')
                
                # Paginate results
                paginator = Paginator(exploits, limit)
                page_obj = paginator.get_page(page)
                
                # Format results
                results = []
                for exploit in page_obj:
                    results.append({
                        'id': exploit.id,
                        'exploit_id': exploit.exploit_id,
                        'title': exploit.title,
                        'description': exploit.description[:200] + '...' if len(exploit.description) > 200 else exploit.description,
                        'type': exploit.type,
                        'platform': exploit.platform,
                        'cve_id': exploit.cve_id,
                        'date_published': exploit.date_published.isoformat() if exploit.date_published else None,
                        'verified': exploit.verified,
                        'source': exploit.source.name,
                        'source_url': exploit.source_url
                    })
                
                return JsonResponse({
                    'status': 'success',
                    'count': paginator.count,
                    'page': page,
                    'pages': paginator.num_pages,
                    'results': results
                })
                
        except Exception as e:
            logger.error(f"Error in exploit search: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)
    
    def post(self, request):
        """Handle POST requests for more complex searches"""
        try:
            data = json.loads(request.body)
            
            # Extract parameters
            query = data.get('query', '')
            cve = data.get('cve', '')
            platform = data.get('platform', '')
            exploit_type = data.get('type', '')
            page = int(data.get('page', 1))
            limit = min(int(data.get('limit', 20)), 100)
            
            # Additional options
            import_results = data.get('import_results', False)
            
            # Search ExploitDB directly
            exploitdb = ExploitDBManager()
            results = exploitdb.search_exploits(
                query=query,
                cve=cve,
                platform=platform,
                exploit_type=exploit_type,
                limit=limit
            )
            
            # Import results if requested
            imported_ids = []
            if import_results and results:
                for result in results:
                    exploit = exploitdb.import_exploit(result)
                    if exploit:
                        imported_ids.append(exploit.id)
            
            return JsonResponse({
                'status': 'success',
                'count': len(results),
                'results': results,
                'imported': len(imported_ids),
                'imported_ids': imported_ids
            })
            
        except Exception as e:
            logger.error(f"Error in exploit search (POST): {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)

class ExploitDetailView(View):
    """
    View for exploit details with robust ID handling and enhanced error management
    """
    def get(self, request, exploit_id):
        """Handle GET requests for exploit details"""
        try:
            # Enhanced ID handling with multiple lookup strategies
            exploit = None
            lookup_attempts = []

            # Try parsing as integer database ID first
            if str(exploit_id).isdigit():
                try:
                    exploit = Exploit.objects.get(id=int(exploit_id))
                    lookup_attempts.append(f"Database ID {exploit_id}")
                except Exploit.DoesNotExist:
                    pass

            # If not found, try looking up by ExploitDB ID
            if not exploit:
                try:
                    exploit = Exploit.objects.get(exploit_id=str(exploit_id))
                    lookup_attempts.append(f"ExploitDB ID {exploit_id}")
                except Exploit.DoesNotExist:
                    pass

            # If still not found, return a detailed error
            if not exploit:
                logger.warning(f"Exploit not found for ID: {exploit_id}")
                return JsonResponse({
                    'status': 'error', 
                    'message': f'No exploit found matching ID: {exploit_id}',
                    'lookup_attempts': lookup_attempts
                }, status=404)

            # Optional code fetching with enhanced error handling
            fetch_code = request.GET.get('fetch_code') == 'true'
            if fetch_code and not exploit.code:
                try:
                    exploitdb = ExploitDBManager()
                    code = exploitdb.get_exploit_code(exploit.exploit_id)
                    if code:
                        exploit.code = code
                        exploit.save()
                except Exception as fetch_error:
                    logger.error(f"Failed to fetch exploit code for {exploit.exploit_id}: {str(fetch_error)}")

            # Prepare rich response with detailed exploit information
            data = {
                'database_id': exploit.id,                             # Unique database ID
                'exploit_id': exploit.exploit_id,                      # External ExploitDB ID
                'title': exploit.title,
                'description': exploit.description,
                'details': {
                    'type': exploit.type,
                    'platform': exploit.platform,
                    'cve_id': exploit.cve_id,
                    'vulnerability_name': exploit.vulnerability_name,
                    'author': exploit.author
                },
                'metadata': {
                    'date_published': exploit.date_published.isoformat() if exploit.date_published else None,
                    'date_added': exploit.date_added.isoformat(),
                    'verified': exploit.verified,
                    'source': {
                        'name': exploit.source.name,
                        'url': exploit.source_url
                    }
                },
                'code_availability': {
                    'has_code': bool(exploit.code),
                    'code_length': len(exploit.code) if exploit.code else 0
                }
            }

            # Conditionally include full code based on request
            include_full_code = request.GET.get('include_code') == 'true'
            if include_full_code and exploit.code:
                data['code'] = exploit.code

            # Log successful retrieval
            logger.info(f"Retrieved exploit details for ID: {exploit_id}")

            return JsonResponse({
                'status': 'success',
                'exploit': data,
                'lookup_method': lookup_attempts[-1] if lookup_attempts else 'Unknown'
            })

        except Exception as e:
            # Comprehensive error logging
            logger.error(f"Critical error retrieving exploit with ID {exploit_id}: {str(e)}", 
                         exc_info=True)
            
            return JsonResponse({
                'status': 'error',
                'message': 'An unexpected error occurred while retrieving exploit details',
                'error_details': str(e)
            }, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class VulnerabilityMatchView(View):
    """View for matching vulnerabilities with exploits"""
    
    def get(self, request, vulnerability_id):
        """Get matches for a vulnerability"""
        try:
            vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
            
            # Get existing matches
            matches = ExploitMatch.objects.filter(vulnerability=vulnerability)
            
            # Format response
            results = []
            for match in matches:
                exploit = match.exploit
                results.append({
                    'id': match.id,
                    'confidence_score': match.confidence_score,
                    'status': match.status,
                    'match_reason': match.match_reason,
                    'matched_by': match.matched_by,
                    'match_date': match.match_date.isoformat(),
                    'exploit': {
                        'id': exploit.id,
                        'exploit_id': exploit.exploit_id,
                        'title': exploit.title,
                        'description': exploit.description[:200] + '...' if len(exploit.description) > 200 else exploit.description,
                        'cve_id': exploit.cve_id,
                        'type': exploit.type,
                        'platform': exploit.platform,
                        'source': exploit.source.name,
                        'verified': exploit.verified,
                        'has_code': bool(exploit.code),
                        'source_url': exploit.source_url
                    }
                })
                
            return JsonResponse({
                'status': 'success',
                'vulnerability': {
                    'id': vulnerability.id,
                    'name': vulnerability.name,
                    'severity': vulnerability.severity,
                    'target': vulnerability.target
                },
                'matches': results,
                'count': len(results)
            })
            
        except Exception as e:
            logger.error(f"Error getting vulnerability matches: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)
    
    def post(self, request, vulnerability_id):
        """Find new matches for a vulnerability"""
        try:
            vulnerability = get_object_or_404(Vulnerability, id=vulnerability_id)
            
            # Create matcher
            matcher = ExploitMatcher()
            
            # Run matching algorithm
            matches = matcher.match_vulnerability(vulnerability)
            
            return JsonResponse({
                'status': 'success',
                'message': f"Found {len(matches)} potential matches",
                'matches_found': len(matches)
            })
            
        except Exception as e:
            logger.error(f"Error matching vulnerability: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)

@method_decorator(csrf_exempt, name='dispatch')
class ExploitSyncView(View):
    """View for synchronizing exploits from ExploitDB"""
    
    def get(self, request):
        """Get exploit sync status"""
        try:
            from django.db.models import Count
            
            # Get exploit stats
            total_exploits = Exploit.objects.count()
            exploits_by_source = Exploit.objects.values('source__name').annotate(count=Count('id'))
            
            # Get latest exploits
            latest_exploits = Exploit.objects.order_by('-date_added')[:5].values(
                'id', 'exploit_id', 'title', 'date_added'
            )
            
            # Format response
            return JsonResponse({
                'status': 'success',
                'total_exploits': total_exploits,
                'by_source': list(exploits_by_source),
                'latest_exploits': list(latest_exploits)
            })
            
        except Exception as e:
            logger.error(f"Error getting exploit sync status: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)
    
    def post(self, request):
        """Sync exploits from ExploitDB"""
        try:
            data = json.loads(request.body)
            
            # Get sync limit
            limit = int(data.get('limit', 100)) # Increase the sync limit to 2000
            
            # Create ExploitDB manager
            manager = ExploitDBManager()
            
            # Run sync
            results = manager.sync_recent_exploits(limit)
            
            return JsonResponse({
                'status': 'success',
                'message': f"Synced {results['new']} new exploits, updated {results['updated']} existing exploits",
                'stats': results
            })
            
        except Exception as e:
            logger.error(f"Error syncing exploits: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)

class ExploitCodeView(View):
    """View for exploit code"""
    
    def get(self, request, exploit_id):
        """Get exploit code"""
        try:
            # Get the exploit
            exploit = get_object_or_404(Exploit, id=exploit_id)
            
            # Check if we have code and need to fetch
            fetch = request.GET.get('fetch') == 'true'
            
            if not exploit.code and fetch:
                # Fetch code
                manager = ExploitDBManager()
                code = manager.get_exploit_code(exploit.exploit_id)
                
                if code:
                    exploit.code = code
                    exploit.save()
            
            # Check if we still don't have code
            if not exploit.code:
                return JsonResponse({
                    'status': 'error',
                    'message': 'Exploit code not available'
                }, status=404)
            
            # Return raw code if requested
            if request.GET.get('raw') == 'true':
                return HttpResponse(exploit.code, content_type='text/plain')
            
            # Check if this is actual executable code or just a description
            code_content = exploit.code
            is_executable = self._is_executable_code(code_content, exploit.type, exploit.platform)
            
            # Extract code snippets if this is just a description
            code_snippets = []
            if not is_executable:
                code_snippets = self._extract_code_snippets(code_content)
            
            # Return code in JSON response with improved structure
            return JsonResponse({
                'status': 'success',
                'exploit_id': exploit.exploit_id,
                'title': exploit.title,
                'content_type': 'executable_code' if is_executable else 'advisory',
                'code': code_content,
                'code_snippets': code_snippets
            })
            
        except Exception as e:
            logger.error(f"Error getting exploit code: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)
    
    def _is_executable_code(self, content, exploit_type, platform):
        """
        Determine if content is likely executable code rather than just a description
        """
        # Check if content contains common code indicators
        code_indicators = [
            '#!/', 'import ', 'function ', 'def ', 'class ', '<script',
            '#include', 'int main', 'public class', 'void '
        ]
        
        # Check if content has a high ratio of code indicators
        if any(indicator in content for indicator in code_indicators):
            return True
            
        # For specific platform/types, check patterns
        if platform == 'php' and ('<?php' in content or '<?=' in content):
            return True
        if exploit_type == 'shellcode' and ('\\x' in content and content.count('\\x') > 5):
            return True
            
        # Check if most of the content is code-like (fewer natural language sentences)
        sentences = content.split('.')
        if len(sentences) < 3 and len(content) > 50:
            return True
            
        return False
    
    def _extract_code_snippets(self, content):
        """
        Extract code snippets from a descriptive writeup with improved sanitization
        """
        snippets = []
        
        # Look for code blocks with common patterns
        # Pattern 1: Code between triple backticks (markdown style)
        import re
        code_blocks = re.findall(r'```(?:\w+)?\n(.*?)\n```', content, re.DOTALL)
        snippets.extend([block.strip() for block in code_blocks if block.strip()])
        
        # Pattern 2: Indented code blocks (4+ spaces)
        lines = content.split('\n')
        current_snippet = []
        in_snippet = False
        
        for line in lines:
            if line.startswith('    ') or line.startswith('\t'):
                current_snippet.append(line.lstrip())
                in_snippet = True
            elif in_snippet and line.strip() == '':
                # Empty line within snippet
                current_snippet.append('')
            elif in_snippet:
                # End of snippet
                if current_snippet:
                    snippets.append('\n'.join(current_snippet))
                current_snippet = []
                in_snippet = False
        
        # Add the last snippet if there is one
        if current_snippet:
            snippets.append('\n'.join(current_snippet))
        
        # Pattern 3: Look for command-line examples
        cmd_snippets = re.findall(r'((?:http|curl|wget|perl|python|bash|sh|nc|ncat|netcat|ssh|ftp)[^\n]+)', content)
        snippets.extend([s.strip() for s in cmd_snippets if len(s.strip()) > 10])
        
        # Pattern 4: Look for URLs that might be exploitation examples
        urls = re.findall(r'((?:http|https)://[^\s]+)', content)
        exploit_urls = [url for url in urls if 'cgi' in url or '?' in url or any(p in url for p in ['php', 'asp', 'jsp'])]
        snippets.extend(exploit_urls)
        
        # Deduplicate and filter out empty snippets
        unique_snippets = []
        seen = set()
        for snippet in snippets:
            snippet_clean = snippet.strip()
            if snippet_clean and snippet_clean not in seen:
                seen.add(snippet_clean)
                unique_snippets.append(snippet_clean)
        
        return unique_snippets

@method_decorator(csrf_exempt, name='dispatch')
class MatchUpdateView(View):
    """View for updating exploit matches"""
    
    def post(self, request, match_id):
        """Update match status"""
        try:
            # Ensure request.body is not empty
            if not request.body:
                return JsonResponse({
                    'status': 'error',
                    'message': 'Empty request body. Expected JSON data.'
                }, status=400)
                
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as json_error:
                return JsonResponse({
                    'status': 'error',
                    'message': f'Invalid JSON format: {str(json_error)}'
                }, status=400)
            
            # Get the match
            match = get_object_or_404(ExploitMatch, id=match_id)
            
            # Update fields
            if 'status' in data:
                # Validate status value
                valid_statuses = [choice[0] for choice in ExploitMatch.STATUS_CHOICES]
                if data['status'] not in valid_statuses:
                    return JsonResponse({
                        'status': 'error',
                        'message': f'Invalid status value. Must be one of: {", ".join(valid_statuses)}'
                    }, status=400)
                match.status = data['status']
                
            if 'notes' in data:
                match.notes = data['notes']
                
            if 'confidence_score' in data:
                try:
                    confidence_score = float(data['confidence_score'])
                    if not (0.0 <= confidence_score <= 1.0):
                        return JsonResponse({
                            'status': 'error',
                            'message': 'Confidence score must be between 0.0 and 1.0'
                        }, status=400)
                    match.confidence_score = confidence_score
                except ValueError:
                    return JsonResponse({
                        'status': 'error',
                        'message': 'Invalid confidence score format. Must be a number between 0.0 and 1.0.'
                    }, status=400)
            
            # Save the match
            match.save()
            
            return JsonResponse({
                'status': 'success',
                'message': 'Match updated successfully',
                'match': {
                    'id': match.id,
                    'status': match.status,
                    'notes': match.notes,
                    'confidence_score': match.confidence_score
                }
            })
            
        except Exception as e:
            logger.error(f"Error updating match: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)
            
@method_decorator(csrf_exempt, name='dispatch')
class MatchAllVulnerabilitiesView(View):
    """View for matching all vulnerabilities with exploits"""
    
    def post(self, request):
        """Find new matches for all vulnerabilities"""
        try:
            # Get all unmatched vulnerabilities
            vulnerabilities = Vulnerability.objects.filter(
                exploit_matches__isnull=True  # No existing matches
            ).distinct()
            
            # Create matcher
            matcher = ExploitMatcher()
            
            # Track results
            total_vulnerabilities = vulnerabilities.count()
            matched_vulnerabilities = 0
            total_matches = 0
            match_details = []
            
            # Process each vulnerability
            for vuln in vulnerabilities:
                try:
                    # Run matching algorithm
                    matches = matcher.match_vulnerability(vuln)
                    
                    if matches:
                        matched_vulnerabilities += 1
                        total_matches += len(matches)
                        match_details.append({
                            'vulnerability_id': vuln.id,
                            'name': vuln.name,
                            'target': vuln.target,
                            'matches': len(matches)
                        })
                except Exception as vuln_error:
                    logger.error(f"Error matching vulnerability ID {vuln.id}: {str(vuln_error)}")
            
            return JsonResponse({
                'status': 'success',
                'message': f"Found {total_matches} matches for {matched_vulnerabilities} vulnerabilities",
                'total_vulnerabilities': total_vulnerabilities,
                'matched_vulnerabilities': matched_vulnerabilities,
                'total_matches': total_matches,
                'details': match_details
            })
            
        except Exception as e:
            logger.error(f"Error matching all vulnerabilities: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)